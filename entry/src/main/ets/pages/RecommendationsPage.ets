// RecommendationsPage.ets - æ¨èé¡µé¢ (æ²‰æµ¸å¼åŒåˆ—ç€‘å¸ƒæµ)
// åŒ…å«ã€Œæ¨èã€å’Œã€Œçƒ­æ¦œã€ä¸¤ä¸ªTab
// å‚è€ƒ RecipesPage çš„ç€‘å¸ƒæµå®ç°

import { router } from '@kit.ArkUI';
import APIService from '../services/APIService';
import { Recipe, RecipesResponse, Ingredient, RecommendedRecipe, RecommendationsResponse } from '../models/Recipe';
import promptAction from '@ohos.promptAction';

// Tabç±»å‹æšä¸¾
enum TabType {
  RECOMMENDATION = 0,
  HOT = 1
}

// æ¨èé…æ–¹æ•°æ®æºç±» - ç”¨äºLazyForEach
class RecommendedRecipeDataSource implements IDataSource {
  private listeners: DataChangeListener[] = [];
  private originDataArray: RecommendedRecipe[] = [];

  public totalCount(): number {
    return this.originDataArray.length;
  }

  public getData(index: number): RecommendedRecipe {
    return this.originDataArray[index];
  }

  public registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }

  public unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }

  public notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }

  public setData(data: RecommendedRecipe[]) {
    this.originDataArray = data;
    this.notifyDataReload();
  }

  public addData(data: RecommendedRecipe[]) {
    const startIndex = this.originDataArray.length;
    this.originDataArray = this.originDataArray.concat(data);
    data.forEach((_, i) => {
      this.notifyDataAdd(startIndex + i);
    });
  }

  public notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }

  public clear() {
    this.originDataArray = [];
    this.notifyDataReload();
  }
}

// çƒ­æ¦œé…æ–¹æ•°æ®æºç±» - ç”¨äºLazyForEach
class RecipeDataSource implements IDataSource {
  private listeners: DataChangeListener[] = [];
  private originDataArray: Recipe[] = [];

  public totalCount(): number {
    return this.originDataArray.length;
  }

  public getData(index: number): Recipe {
    return this.originDataArray[index];
  }

  public registerDataChangeListener(listener: DataChangeListener): void {
    if (this.listeners.indexOf(listener) < 0) {
      this.listeners.push(listener);
    }
  }

  public unregisterDataChangeListener(listener: DataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos >= 0) {
      this.listeners.splice(pos, 1);
    }
  }

  public notifyDataReload(): void {
    this.listeners.forEach(listener => {
      listener.onDataReloaded();
    })
  }

  public notifyDataAdd(index: number): void {
    this.listeners.forEach(listener => {
      listener.onDataAdd(index);
    })
  }

  public setData(data: Recipe[]) {
    this.originDataArray = data;
    this.notifyDataReload();
  }

  public addData(data: Recipe[]) {
    const startIndex = this.originDataArray.length;
    this.originDataArray = this.originDataArray.concat(data);
    data.forEach((_, i) => {
      this.notifyDataAdd(startIndex + i);
    });
  }

  public clear() {
    this.originDataArray = [];
    this.notifyDataReload();
  }
}

@Component
export struct RecommendationsPage {
  // TabçŠ¶æ€
  @State currentTab: TabType = TabType.RECOMMENDATION;
  @State selectedTabIndex: number = 0;
  
  // æ¨èTabæ•°æ®
  @State recommendDataSource: RecommendedRecipeDataSource = new RecommendedRecipeDataSource();
  @State isLoadingRecommend: boolean = false;
  @State isRefreshingRecommend: boolean = false;
  @State recommendPage: number = 1;
  @State recommendTotalPages: number = 1;
  @State recommendError: string = '';
  @State recommendMessage: string = ''; // æ— æ¨èæ—¶çš„æç¤ºä¿¡æ¯
  @State recommendDataVersion: number = 0; // æ•°æ®ç‰ˆæœ¬å·ï¼Œç”¨äºå¼ºåˆ¶åˆ·æ–°
  @State showMatchPercentage: boolean = true; // æ˜¯å¦æ˜¾ç¤ºåŒ¹é…åº¦æ ‡ç­¾
  @State showRecommendReason: boolean = true; // æ˜¯å¦æ˜¾ç¤ºæ¨èç†ç”±
  
  // çƒ­æ¦œTabæ•°æ®
  @State hotDataSource: RecipeDataSource = new RecipeDataSource();
  @State isLoadingHot: boolean = false;
  @State isRefreshingHot: boolean = false;
  @State hotPage: number = 1;
  @State hotTotalPages: number = 1;
  @State hotError: string = '';
  @State hotDataVersion: number = 0; // æ•°æ®ç‰ˆæœ¬å·ï¼Œç”¨äºå¼ºåˆ¶åˆ·æ–°
  
  private pageSize: number = 20; // æ¯é¡µåŠ è½½æ•°é‡
  private scroller: Scroller = new Scroller();
  
  aboutToAppear(): void {
    // åˆå§‹åŠ è½½æ¨èTabæ•°æ®
    if (this.recommendDataSource.totalCount() === 0) {
      this.loadRecommendations(true);
    }
  }
  
  /**
   * åŠ è½½æ¨èTabæ•°æ® (ä½¿ç”¨åç«¯æ¨èç®—æ³•ï¼Œæ”¯æŒåˆ†é¡µ)
   */
  private async loadRecommendations(reset: boolean): Promise<void> {
    if (this.isLoadingRecommend) return;
    
    if (reset) {
      this.recommendPage = 1;
      this.recommendTotalPages = 1;
    }
    
    this.isLoadingRecommend = true;
    this.recommendError = '';
    this.recommendMessage = '';
    
    try {
      const apiService = APIService.getInstance();
      const response: RecommendationsResponse = await apiService.fetchRecommendations(this.recommendPage, 10);
      
      console.info(`[RecommendationsPage] APIå“åº”:`, JSON.stringify(response));
      
      const recommendations: Array<RecommendedRecipe> = response.recommendations || [];
      
      if (recommendations.length === 0 && response.message) {
        this.recommendMessage = response.message;
      }
      
      // æ‰“å°æ¯ä¸ªæ¨èçš„è¯¦ç»†ä¿¡æ¯
      recommendations.forEach((rec, index) => {
        console.info(`[RecommendationsPage] æ¨è${index}: id=${rec.id}, name=${rec.name}, abv=${rec.estimatedAbv}, match=${rec.matchPercentage}%`);
      });
      
      if (reset) {
        this.recommendDataSource.setData(recommendations);
        // åˆ·æ–°æ—¶æ›´æ–°ç‰ˆæœ¬å·ï¼Œå¼ºåˆ¶LazyForEaché‡æ–°æ¸²æŸ“
        this.recommendDataVersion++;
      } else {
        this.recommendDataSource.addData(recommendations);
      }
      
      // æ›´æ–°åˆ†é¡µä¿¡æ¯
      if (response.pagination) {
        this.recommendPage = response.pagination.currentPage + 1;
        this.recommendTotalPages = response.pagination.totalPages;
      }
      
      console.info(`[RecommendationsPage] æ¨èåŠ è½½æˆåŠŸ: ${recommendations.length}æ¡, ç¬¬${response.pagination?.currentPage}é¡µ/${response.pagination?.totalPages}é¡µ`);
    } catch (error) {
      console.error('[RecommendationsPage] æ¨èåŠ è½½å¤±è´¥:', error);
      this.recommendError = 'åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    } finally {
      this.isLoadingRecommend = false;
    }
  }
  
  /**
   * åŠ è½½çƒ­æ¦œTabæ•°æ® (æŒ‰ç‚¹èµæ•°æ’åº)
   */
  private async loadHotList(reset: boolean): Promise<void> {
    if (this.isLoadingHot) return;
    
    if (reset) {
      this.hotPage = 1;
      this.hotTotalPages = 1;
    }
    
    this.isLoadingHot = true;
    this.hotError = '';
    
    try {
      const apiService = APIService.getInstance();
      const result: object = await apiService.fetchRecipes(
        this.hotPage,
        this.pageSize,
        '',
        'likes' // æŒ‰ç‚¹èµæ•°æ’åº
      );
      
      const response: RecipesResponse = result as RecipesResponse;
      const newRecipes: Array<Recipe> = response.recipes || [];
      
      if (reset) {
        this.hotDataSource.setData(newRecipes);
        // åˆ·æ–°æ—¶æ›´æ–°ç‰ˆæœ¬å·ï¼Œå¼ºåˆ¶LazyForEaché‡æ–°æ¸²æŸ“
        this.hotDataVersion++;
      } else {
        this.hotDataSource.addData(newRecipes);
      }
      
      this.hotPage = response.currentPage + 1;
      this.hotTotalPages = response.totalPages;
      
      console.info(`[RecommendationsPage] çƒ­æ¦œåŠ è½½æˆåŠŸ: ${newRecipes.length}æ¡`);
    } catch (error) {
      console.error('[RecommendationsPage] çƒ­æ¦œåŠ è½½å¤±è´¥:', error);
      this.hotError = 'åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    } finally {
      this.isLoadingHot = false;
    }
  }
  
  /**
   * åŠ è½½æ›´å¤šæ•°æ®
   */
  private loadMore(): void {
    if (this.currentTab === TabType.RECOMMENDATION) {
      if (this.recommendPage <= this.recommendTotalPages && !this.isLoadingRecommend) {
        this.loadRecommendations(false);
      }
    } else if (this.currentTab === TabType.HOT) {
      if (this.hotPage <= this.hotTotalPages && !this.isLoadingHot) {
        this.loadHotList(false);
      }
    }
  }
  
  /**
   * åˆ‡æ¢Tab
   */
  private onTabChange(index: number): void {
    this.selectedTabIndex = index;
    this.currentTab = index as TabType;
    
    // åˆ‡æ¢åˆ°çƒ­æ¦œä¸”æœªåŠ è½½æ•°æ®æ—¶ï¼ŒåŠ è½½æ•°æ®
    if (this.currentTab === TabType.HOT && this.hotDataSource.totalCount() === 0) {
      this.loadHotList(true);
    }
  }
  
  /**
   * ä¸‹æ‹‰åˆ·æ–° - æ¨èTab
   */
  private async onRefreshRecommend(): Promise<void> {
    console.info('[RecommendationsPage] æ¨èTabä¸‹æ‹‰åˆ·æ–°å¼€å§‹');
    this.isRefreshingRecommend = true;
    
    try {
      // é‡ç½®é¡µç å¹¶é‡æ–°åŠ è½½ç¬¬ä¸€é¡µ
      await this.loadRecommendations(true);
    } finally {
      this.isRefreshingRecommend = false;
      console.info('[RecommendationsPage] æ¨èTabä¸‹æ‹‰åˆ·æ–°å®Œæˆ');
    }
  }
  
  /**
   * ä¸‹æ‹‰åˆ·æ–° - çƒ­æ¦œTab
   */
  private async onRefreshHot(): Promise<void> {
    console.info('[RecommendationsPage] çƒ­æ¦œTabä¸‹æ‹‰åˆ·æ–°å¼€å§‹');
    this.isRefreshingHot = true;
    
    try {
      // é‡ç½®é¡µç å¹¶é‡æ–°åŠ è½½ç¬¬ä¸€é¡µ
      await this.loadHotList(true);
    } finally {
      this.isRefreshingHot = false;
      console.info('[RecommendationsPage] çƒ­æ¦œTabä¸‹æ‹‰åˆ·æ–°å®Œæˆ');
    }
  }
  
  /**
   * è·³è½¬åˆ°é…æ–¹è¯¦æƒ…
   */
  private openRecipeDetail(recipeId: string): void {
    router.pushUrl({
      url: 'pages/RecipeDetailPage',
      params: { recipeId: recipeId }
    });
  }
  
  build() {
    Column() {
      // é¡¶éƒ¨Tabå¯¼èˆªæ 
      this.buildTabBar()
      
      // å†…å®¹åŒºåŸŸ - æ ¹æ®å½“å‰Tabæ˜¾ç¤ºä¸åŒå†…å®¹
      if (this.currentTab === TabType.RECOMMENDATION) {
        this.buildRecommendContent()
      } else {
        this.buildHotContent()
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F6F6F6')
  }
  
  /**
   * é¡¶éƒ¨Tabå¯¼èˆªæ 
   */
  @Builder
  buildTabBar() {
    Column() {
      // Tabæ ‡ç­¾è¡Œ
      Row() {
        // æ¨èTab
        Column() {
          Text('æ¨è')
            .fontSize(this.selectedTabIndex === 0 ? 18 : 16)
            .fontWeight(this.selectedTabIndex === 0 ? FontWeight.Bold : FontWeight.Normal)
            .fontColor(this.selectedTabIndex === 0 ? '#1A1A1A' : '#999999')
            .animation({
              duration: 200,
              curve: Curve.EaseInOut
            })
          
          // åº•éƒ¨æŒ‡ç¤ºå™¨
          if (this.selectedTabIndex === 0) {
            Divider()
              .width(24)
              .height(3)
              .color('#007DFF')
              .borderRadius(1.5)
              .margin({ top: 4 })
          }
        }
        .width('50%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .onClick(() => this.onTabChange(0))
        
        // çƒ­æ¦œTab
        Column() {
          Text('çƒ­æ¦œ')
            .fontSize(this.selectedTabIndex === 1 ? 18 : 16)
            .fontWeight(this.selectedTabIndex === 1 ? FontWeight.Bold : FontWeight.Normal)
            .fontColor(this.selectedTabIndex === 1 ? '#1A1A1A' : '#999999')
            .animation({
              duration: 200,
              curve: Curve.EaseInOut
            })
          
          // åº•éƒ¨æŒ‡ç¤ºå™¨
          if (this.selectedTabIndex === 1) {
            Divider()
              .width(24)
              .height(3)
              .color('#007DFF')
              .borderRadius(1.5)
              .margin({ top: 4 })
          }
        }
        .width('50%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .onClick(() => this.onTabChange(1))
      }
      .width('100%')
      .height(50)
      
      // åˆ†å‰²çº¿
      Divider()
        .color('#E8E8E8')
        .strokeWidth(1)
    }
    .width('100%')
    .backgroundColor(Color.White)
  }
  
  /**
   * æ¨èTabå†…å®¹
   */
  @Builder
  buildRecommendContent() {
    if (this.recommendDataSource.totalCount() === 0 && !this.isLoadingRecommend) {
      // æ˜¾ç¤ºç©ºçŠ¶æ€æˆ–æç¤ºä¿¡æ¯
      this.buildEmptyState('æ¨è', this.recommendMessage)
    } else {
      Refresh({ refreshing: $$this.isRefreshingRecommend }) {
        WaterFlow({ footer: () => { this.buildFooter(this.isLoadingRecommend, this.recommendPage > this.recommendTotalPages) } }) {
          LazyForEach(this.recommendDataSource, (recipe: RecommendedRecipe, index: number) => {
            FlowItem() {
              RecommendedRecipeCard({
                recipe: recipe,
                cardRatio: this.getCardRatio(index),
                showMatchPercentage: this.showMatchPercentage,
                showRecommendReason: this.showRecommendReason,
                onTap: () => { this.openRecipeDetail(recipe.id) }
              })
            }
            .width('100%')
          }, (recipe: RecommendedRecipe, index: number) => `${this.recommendDataVersion}_${recipe.id}_${index}`)
        }
        .columnsTemplate('1fr 1fr')
        .columnsGap(10)
        .rowsGap(10)
        .padding({ left: 10, right: 10, top: 10, bottom: 10 })
        .width('100%')
        .layoutWeight(1)
        .onReachEnd(() => {
          this.loadMore();
        })
      }
      .width('100%')
      .layoutWeight(1)
      .onRefreshing(async () => {
        await this.onRefreshRecommend();
      })
    }
  }
  
  /**
   * çƒ­æ¦œTabå†…å®¹
   */
  @Builder
  buildHotContent() {
    if (this.hotDataSource.totalCount() === 0 && !this.isLoadingHot) {
      this.buildEmptyState('çƒ­æ¦œ')
    } else {
      Refresh({ refreshing: $$this.isRefreshingHot }) {
        WaterFlow({ footer: () => { this.buildFooter(this.isLoadingHot, this.hotPage > this.hotTotalPages) } }) {
          LazyForEach(this.hotDataSource, (recipe: Recipe, index: number) => {
            FlowItem() {
              RecipeWaterfallCard({
                recipe: recipe,
                cardRatio: this.getCardRatio(index),
                showRank: true,
                rank: index + 1,
                onTap: () => { this.openRecipeDetail(recipe.id) }
              })
            }
            .width('100%')
          }, (recipe: Recipe, index: number) => `${this.hotDataVersion}_${recipe.id}_${index}`)
        }
        .columnsTemplate('1fr 1fr')
        .columnsGap(10)
        .rowsGap(10)
        .padding({ left: 10, right: 10, top: 10, bottom: 10 })
        .width('100%')
        .layoutWeight(1)
        .onReachEnd(() => {
          this.loadMore();
        })
      }
      .width('100%')
      .layoutWeight(1)
      .onRefreshing(async () => {
        await this.onRefreshHot();
      })
    }
  }
  
  /**
   * ç©ºçŠ¶æ€
   */
  @Builder
  buildEmptyState(tabName: string, message?: string) {
    Column({ space: 16 }) {
      Text('âœ¨')
        .fontSize(64)
        .opacity(0.3)
      
      Text(message || `æš‚æ— ${tabName}å†…å®¹`)
        .fontSize(16)
        .fontColor('#999999')
        .textAlign(TextAlign.Center)
        .padding({ left: 20, right: 20 })
      
      Button('åˆ·æ–°')
        .fontSize(14)
        .backgroundColor('#007DFF')
        .borderRadius(20)
        .padding({ left: 24, right: 24, top: 8, bottom: 8 })
        .margin({ top: 16 })
        .onClick(() => {
          if (this.currentTab === TabType.RECOMMENDATION) {
            this.loadRecommendations(true);
          } else {
            this.loadHotList(true);
          }
        })
    }
    .width('100%')
    .layoutWeight(1)
    .justifyContent(FlexAlign.Center)
    .padding(32)
  }
  
  /**
   * åº•éƒ¨åŠ è½½çŠ¶æ€
   */
  @Builder
  buildFooter(isLoading: boolean, isEnd: boolean): void {
    Row() {
      if (isLoading) {
        LoadingProgress().width(20).height(20).margin({ right: 8 })
        Text('åŠ è½½ä¸­...').fontSize(14).fontColor('#999999')
      } else if (isEnd) {
        Text('æ²¡æœ‰æ›´å¤šäº†').fontSize(14).fontColor('#999999')
      }
    }
    .width('100%')
    .height(50)
    .justifyContent(FlexAlign.Center)
  }
  
  /**
   * è·å–å¡ç‰‡æ¯”ä¾‹ (3:4 å’Œ 1:1 æ··åˆ)
   */
  private getCardRatio(index: number): number {
    // æ¯4ä¸ªå¡ç‰‡ä¸­ï¼Œå‰2ä¸ªä½¿ç”¨3:4ï¼Œå2ä¸ªä½¿ç”¨1:1
    const pattern = index % 4;
    return (pattern === 0 || pattern === 1) ? 0.75 : 1.0; // 3:4 = 0.75, 1:1 = 1.0
  }
}

/**
 * æ¨èå¡ç‰‡ç»„ä»¶ - å¸¦åŒ¹é…åº¦å’Œæ¨èç†ç”±
 */
@Component
struct RecommendedRecipeCard {
  @Prop recipe: RecommendedRecipe;
  @Prop cardRatio: number = 0.75; // é»˜è®¤3:4æ¯”ä¾‹
  @Prop showMatchPercentage: boolean = true; // æ˜¯å¦æ˜¾ç¤ºåŒ¹é…åº¦æ ‡ç­¾
  @Prop showRecommendReason: boolean = true; // æ˜¯å¦æ˜¾ç¤ºæ¨èç†ç”±
  onTap?: () => void;
  
  build() {
    Column() {
      // å›¾ç‰‡åŒºåŸŸ
      Stack({ alignContent: Alignment.TopEnd }) {
        Image($r('app.media.wine'))
          .width('100%')
          .aspectRatio(this.cardRatio) // åŠ¨æ€å®½é«˜æ¯”
          .objectFit(ImageFit.Cover)
          .borderRadius({ topLeft: 8, topRight: 8 })
        
        // åŒ¹é…åº¦æ ‡ç­¾ï¼ˆå³ä¸Šè§’ï¼‰
        if (this.showMatchPercentage && this.recipe.matchPercentage > 0) {
          Row({ space: 2 }) {
            Text(`${this.recipe.matchPercentage}%`)
              .fontSize(12)
              .fontWeight(FontWeight.Bold)
              .fontColor(Color.White)
            Text('åŒ¹é…')
              .fontSize(10)
              .fontColor(Color.White)
          }
          .padding({ left: 8, right: 8, top: 4, bottom: 4 })
          .backgroundColor(this.getMatchColor(this.recipe.matchPercentage))
          .borderRadius({ topRight: 8, bottomLeft: 8 })
        }
      }
      .width('100%')
      
      // å†…å®¹åŒºåŸŸ
      Column() {
        // æ ‡é¢˜
        Text(this.recipe.name)
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
          .fontColor('#333')
          .width('100%')
          .textAlign(TextAlign.Start)
        
        // æ¨èç†ç”±ï¼ˆé…’å“åç§°ä¸‹æ–¹ï¼‰
        if (this.showRecommendReason && this.recipe.reason) {
          Text(this.recipe.reason)
            .fontSize(10)
            .fontColor('#666')
            .width('100%')
            .margin({ top: 4 })
            .lineHeight(14)
        }
        
        // ABVæ ‡ç­¾å’Œç‚¹èµæ•°ï¼ˆåŒä¸€è¡Œï¼‰
        Row({ space: 8 }) {
          // ABVæ ‡ç­¾
          if (this.recipe.estimatedAbv !== undefined && this.recipe.estimatedAbv !== null) {
            Text(`${Math.round(Number(this.recipe.estimatedAbv))}%`)
              .fontSize(13)
              .fontWeight(FontWeight.Bold)
              .fontColor('#FF6B00')
              .backgroundColor('#FFF0E0')
              .padding({ left: 6, right: 6, top: 2, bottom: 2 })
              .borderRadius(4)
              .flexShrink(0)
          }
          
          Blank()
          
          // ç‚¹èµæ•°ï¼ˆå³ä¸‹è§’ï¼‰
          Row({ space: 2 }) {
            Text('ğŸ¤')
              .fontSize(12)
            Text(`${this.recipe.likeCount || 0}`)
              .fontSize(12)
              .fontColor('#666')
          }
          .flexShrink(0)
        }
        .margin({ top: 6 })
        .width('100%')
        .alignItems(VerticalAlign.Center)
        .justifyContent(FlexAlign.SpaceBetween)
      }
      .padding(8)
      .backgroundColor(Color.White)
      .borderRadius({ bottomLeft: 8, bottomRight: 8 })
      .alignItems(HorizontalAlign.Start)
    }
    .width('100%')
    .borderRadius(8)
    .backgroundColor(Color.White)
    .shadow({ radius: 4, color: '#1A000000', offsetY: 2 })
    .onClick(() => {
      if (this.onTap) this.onTap();
    })
  }
  
  /**
   * è·å–åŒ¹é…åº¦é¢œè‰²
   */
  private getMatchColor(percentage: number): string {
    if (percentage >= 80) {
      return '#4CAF50'; // ç»¿è‰² - é«˜åŒ¹é…
    } else if (percentage >= 60) {
      return '#FF9800'; // æ©™è‰² - ä¸­ç­‰åŒ¹é…
    } else {
      return '#9E9E9E'; // ç°è‰² - ä½åŒ¹é…
    }
  }
}

/**
 * ç€‘å¸ƒæµå¡ç‰‡ç»„ä»¶ - å‚è€ƒRecipesPageçš„RecipeCard
 */
@Component
struct RecipeWaterfallCard {
  @Prop recipe: Recipe;
  @Prop cardRatio: number = 0.75; // é»˜è®¤3:4æ¯”ä¾‹
  @Prop showRank: boolean = false; // æ˜¯å¦æ˜¾ç¤ºæ’å
  @Prop rank: number = 0; // æ’åæ•°å­—
  onTap?: () => void;
  
  build() {
    Column() {
      // å›¾ç‰‡åŒºåŸŸ
      Stack({ alignContent: Alignment.TopStart }) {
        Image($r('app.media.wine'))
          .width('100%')
          .aspectRatio(this.cardRatio) // åŠ¨æ€å®½é«˜æ¯”
          .objectFit(ImageFit.Cover)
          .borderRadius({ topLeft: 8, topRight: 8 })
        
        // çƒ­æ¦œæ’åæ ‡ç­¾
        if (this.showRank && this.rank > 0 && this.rank <= 3) {
          Row() {
            Text(`${this.rank}`)
              .fontSize(16)
              .fontWeight(FontWeight.Bold)
              .fontColor(Color.White)
          }
          .width(32)
          .height(32)
          .justifyContent(FlexAlign.Center)
          .backgroundColor(this.getRankColor(this.rank))
          .borderRadius({ topLeft: 8, bottomRight: 8 })
        } else if (this.showRank && this.rank > 0) {
          Row() {
            Text(`${this.rank}`)
              .fontSize(12)
              .fontWeight(FontWeight.Bold)
              .fontColor(Color.White)
          }
          .padding({ left: 6, right: 6, top: 3, bottom: 3 })
          .backgroundColor('rgba(0, 0, 0, 0.5)')
          .borderRadius({ topLeft: 8, bottomRight: 8 })
        }
      }
      .width('100%')
      
      // å†…å®¹åŒºåŸŸ
      Column() {
        // æ ‡é¢˜
        Text(this.recipe.name)
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
          .fontColor('#333')
          .width('100%')
          .textAlign(TextAlign.Start)
        
        // ABVæ ‡ç­¾å’Œé…æ–™é¢„è§ˆ
        Row({ space: 4 }) {
          Text(`${this.recipe.estimatedAbv.toFixed(0)}%`)
            .fontSize(13)
            .fontWeight(FontWeight.Bold)
            .fontColor('#FF6B00')
            .backgroundColor('#FFF0E0')
            .padding({ left: 6, right: 6, top: 2, bottom: 2 })
            .borderRadius(4)
            .flexShrink(0)
          
          // é…æ–™é¢„è§ˆ
          if (this.recipe.ingredients && typeof this.recipe.ingredients === 'string') {
            Text(this.recipe.ingredients.split(',').slice(0, 3).join(' '))
              .fontSize(10)
              .fontColor('#999')
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
              .layoutWeight(1)
          }
        }
        .margin({ top: 6 })
        .width('100%')
        
        // åº•éƒ¨ä¿¡æ¯
        Row() {
          // åˆ›å»ºè€…
          Row({ space: 4 }) {
            Image($r('app.media.startIcon'))
              .width(16)
              .height(16)
              .borderRadius(8)
              .flexShrink(0)
            
            Text(this.recipe.createdBy)
              .fontSize(10)
              .fontColor('#666')
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
          }
          .layoutWeight(1)
          .alignItems(VerticalAlign.Center)
          
          // ç‚¹èµæ•°
          Row({ space: 2 }) {
            Text(this.recipe.isLiked ? 'â¤ï¸' : 'ğŸ¤')
              .fontSize(12)
            Text(`${this.recipe.likeCount}`)
              .fontSize(12)
              .fontColor('#666')
          }
          .flexShrink(0)
          .margin({ left: 4 })
        }
        .margin({ top: 8 })
        .width('100%')
        .alignItems(VerticalAlign.Center)
        .justifyContent(FlexAlign.SpaceBetween)
      }
      .padding(8)
      .backgroundColor(Color.White)
      .borderRadius({ bottomLeft: 8, bottomRight: 8 })
      .alignItems(HorizontalAlign.Start)
    }
    .width('100%')
    .borderRadius(8)
    .backgroundColor(Color.White)
    .shadow({ radius: 4, color: '#1A000000', offsetY: 2 })
    .onClick(() => {
      if (this.onTap) this.onTap();
    })
  }
  
  /**
   * è·å–æ’åé¢œè‰²
   */
  private getRankColor(rank: number): string {
    switch (rank) {
      case 1:
        return '#FFD700'; // é‡‘è‰²
      case 2:
        return '#C0C0C0'; // é“¶è‰²
      case 3:
        return '#CD7F32'; // é“œè‰²
      default:
        return 'rgba(0, 0, 0, 0.5)';
    }
  }
}
