// RecommendationsPage.ets - æ¨èé¡µé¢
// å‚è€ƒ Swift é¡¹ç›®ä¸­çš„ RecommendationsView å’Œ LOCAL_RECOMMENDATION_ALGORITHM.md

import { router } from '@kit.ArkUI';
import APIService from '../services/APIService';
import { Recipe, APIIngredient } from '../common/models/Recipe';
import promptAction from '@ohos.promptAction';

// ç”¨æˆ·åå¥½æ¨¡å‹
class UserPreferences {
  preferredAbv: number = 15.0;        // åå¥½çš„é…’ç²¾åº¦
  abvWeight: number = 1.0;            // é…’ç²¾åº¦æƒé‡
  popularityWeight: number = 0.1;     // å—æ¬¢è¿ç¨‹åº¦æƒé‡
  randomWeight: number = 0.3;         // éšæœºå› å­æƒé‡
  favoriteCreators: string[] = [];    // å–œæ¬¢çš„åˆ›å»ºè€…åˆ—è¡¨
  ingredientWeights: Map<string, number> = new Map(); // åŸæ–™åå¥½
  ingredientMatchWeight: number = 1.0; // åŸæ–™åŒ¹é…æƒé‡
}

// è¯„åˆ†åçš„æ¨èé¡¹
interface ScoredRec {
  id: string;
  name: string;
  createdBy: string;
  estimatedAbv: number;
  matchPercentage: number;
  reasons: string[];
  likeCount: number;
  favoriteCount: number;
  ingredients: string;
  ingredientDetails?: APIIngredient[]; // è¯¦ç»†é…æ–™ä¿¡æ¯
}

// è¯„åˆ†ä¸­é—´ç»“æœ
interface ScoredItem {
  recipe: Recipe;
  score: number;
  reasons: string[];
}

@Component
export struct RecommendationsPage {
  @State recs: Array<ScoredRec> = [];        // å½“å‰å±•ç¤ºçš„æ¨è(4ä¸ª)
  @State top20: Array<ScoredRec> = [];       // Top20 æ¨èæ± 
  @State isLoading: boolean = false;
  @State isRefreshing: boolean = false;      // ä¸‹æ‹‰åˆ·æ–°çŠ¶æ€
  @State hasError: boolean = false;
  @State errorMessage: string = '';
  
  aboutToAppear() {
    if (this.top20.length === 0) {
      this.loadRecommendations();
    } else {
      this.pickDisplayFour();
    }
  }
  
  /**
   * åŠ è½½æ¨è
   */
  private async loadRecommendations() {
    this.isLoading = true;
    this.hasError = false;
    this.errorMessage = '';
    
    try {
      console.info('[RecommendationsPage] å¼€å§‹åŠ è½½æ¨è...');
      const apiService = APIService.getInstance();
      
      // 1. è·å–éšæœº100ä¸ªé…æ–¹
      const randomRecipes = await apiService.fetchRandomRecipes(100);
      console.info(`[RecommendationsPage] è·å–åˆ° ${randomRecipes.length} ä¸ªéšæœºé…æ–¹`);
      
      if (!Array.isArray(randomRecipes) || randomRecipes.length === 0) {
        this.errorMessage = 'æš‚æ— é…æ–¹æ•°æ®';
        this.hasError = true;
        return;
      }
      
      // 2. æ„å»ºç”¨æˆ·åå¥½
      const prefs = await this.buildUserPreferences();
      
      // 3. æœ¬åœ°è¯„åˆ†å’Œæ’åº
      const recipes = this.parseRecipes(randomRecipes);
      const scored = this.scoreAndSort(recipes, prefs);
      
      // 4. å–Top20
      this.top20 = scored.slice(0, Math.min(20, scored.length));
      console.info(`[RecommendationsPage] Top20 æ¨èç”Ÿæˆå®Œæˆ`);
      
      // 5. ä»Top20ä¸­éšæœºé€‰4ä¸ªå±•ç¤º
      this.pickDisplayFour();
      
    } catch (error) {
      console.error('[RecommendationsPage] åŠ è½½æ¨èå¤±è´¥:', error);
      this.hasError = true;
      this.errorMessage = error instanceof Error ? error.message : 'åŠ è½½å¤±è´¥';
    } finally {
      this.isLoading = false;
    }
  }
  
  /**
   * ä»Top20ä¸­éšæœºé€‰æ‹©4ä¸ªå±•ç¤º
   */
  private pickDisplayFour() {
    if (this.top20.length === 0) {
      this.recs = [];
      return;
    }
    
    // æ´—ç‰Œç®—æ³•
    const pool = [...this.top20];
    for (let i = pool.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      // ArkTSä¸æ”¯æŒè§£æ„èµ‹å€¼,ä½¿ç”¨ä¸´æ—¶å˜é‡
      const temp = pool[i];
      pool[i] = pool[j];
      pool[j] = temp;
    }
    
    this.recs = pool.slice(0, Math.min(4, pool.length));
    console.info(`[RecommendationsPage] å±•ç¤º ${this.recs.length} ä¸ªæ¨è`);
  }
  
  /**
   * åˆ·æ–°æ¨è - ä¸‹æ‹‰åˆ·æ–°æ—¶è°ƒç”¨
   */
  private async refreshRecommendations() {
    console.info('[RecommendationsPage] ä¸‹æ‹‰åˆ·æ–°å¼€å§‹');
    this.isRefreshing = true;
    
    try {
      // å¦‚æœ top20 ä¸ºç©º,åˆ™å®Œæ•´åŠ è½½
      if (this.top20.length === 0) {
        await this.loadRecommendations();
      } else {
        // å¦åˆ™ä» top20 ä¸­é‡æ–°æŠ½å–4ä¸ª
        this.pickDisplayFour();
        
        // æ‰‹åŠ¨å»¶è¿Ÿä¸€ä¸‹,è®©åˆ·æ–°åŠ¨ç”»æ­£å¸¸æ˜¾ç¤º
        await new Promise<void>((resolve) => {
          setTimeout(() => {
            resolve();
          }, 500);
        });
      }
    } finally {
      this.isRefreshing = false;
      console.info('[RecommendationsPage] ä¸‹æ‹‰åˆ·æ–°å®Œæˆ');
    }
  }
  
  /**
   * æ„å»ºç”¨æˆ·åå¥½
   */
  private async buildUserPreferences(): Promise<UserPreferences> {
    const prefs = new UserPreferences();
    const apiService = APIService.getInstance();
    
    // æœªç™»å½•:ä½¿ç”¨é»˜è®¤åå¥½
    if (!apiService.isLoggedIn) {
      console.info('[RecommendationsPage] æœªç™»å½•,ä½¿ç”¨é»˜è®¤åå¥½');
      return prefs;
    }
    
    try {
      // è·å–ç”¨æˆ·ç‚¹èµå’Œæ”¶è—
      const results = await Promise.all([
        apiService.fetchUserLikes().catch(() => []),
        apiService.fetchUserFavorites().catch(() => [])
      ]);
      const likesData = results[0];
      const favsData = results[1];
      
      const likes = this.parseRecipes(likesData);
      const favs = this.parseRecipes(favsData);
      const all = [...likes, ...favs];
      
      if (all.length > 0) {
        // è®¡ç®—åå¥½ABV(å¹³å‡å€¼)
        const abvSum = all.reduce((sum, r) => sum + r.estimatedAbv, 0);
        prefs.preferredAbv = abvSum / all.length;
        
        // ç»Ÿè®¡å–œæ¬¢çš„ä½œè€…(Top 10)
        const creatorCount: Map<string, number> = new Map();
        all.forEach(r => {
          const count = creatorCount.get(r.createdBy) || 0;
          creatorCount.set(r.createdBy, count + 1);
        });
        prefs.favoriteCreators = Array.from(creatorCount.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map((entry) => entry[0]);
        
        // ç»Ÿè®¡åŸæ–™åå¥½:æ”¶è—è®°2åˆ†,ç‚¹èµè®°1åˆ†
        const ingWeights: Map<string, number> = new Map();
        likes.forEach(r => {
          this.extractIngredientNames(r.ingredients).forEach(name => {
            ingWeights.set(name, (ingWeights.get(name) || 0) + 1);
          });
        });
        favs.forEach(r => {
          this.extractIngredientNames(r.ingredients).forEach(name => {
            ingWeights.set(name, (ingWeights.get(name) || 0) + 2);
          });
        });
        prefs.ingredientWeights = ingWeights;
        
        console.info(`[RecommendationsPage] ç”¨æˆ·åå¥½: ABV=${prefs.preferredAbv.toFixed(1)}, åŸæ–™=${ingWeights.size}ç§`);
      }
    } catch (error) {
      console.warn('[RecommendationsPage] æ„å»ºç”¨æˆ·åå¥½å¤±è´¥:', error);
    }
    
    return prefs;
  }
  
  /**
   * è¯„åˆ†å’Œæ’åº
   */
  private scoreAndSort(recipes: Recipe[], prefs: UserPreferences): ScoredRec[] {
    const scored: Array<ScoredItem> = [];
    
    recipes.forEach(r => {
      // ABVè¯„åˆ†: 10 - abs(recipe.abv - pref.abv)
      const abvScore = Math.max(0, 10 - Math.abs(r.estimatedAbv - prefs.preferredAbv));
      
      // å—æ¬¢è¿ç¨‹åº¦
      const popularityScore = Math.max(0, r.likeCount);
      
      // éšæœºå› å­
      const randomScore = Math.floor(Math.random() * 6); // 0-5
      
      // ä½œè€…åŠ åˆ†
      const creatorBonus = prefs.favoriteCreators.includes(r.createdBy) ? 15 : 0;
      
      // åŸæ–™åŒ¹é…åˆ†
      let ingredientScore = 0;
      const matchedIngs: string[] = [];
      if (prefs.ingredientWeights.size > 0) {
        const recipeIngs = this.extractIngredientNames(r.ingredients);
        recipeIngs.forEach(ing => {
          if (prefs.ingredientWeights.has(ing)) {
            matchedIngs.push(ing);
          }
        });
        ingredientScore = Math.min(4, matchedIngs.length);
      }
      
      // æ€»åˆ†è®¡ç®—
      const score = abvScore * prefs.abvWeight +
                    popularityScore * prefs.popularityWeight +
                    randomScore * prefs.randomWeight +
                    creatorBonus +
                    ingredientScore * prefs.ingredientMatchWeight;
      
      // ç”Ÿæˆæ¨èç†ç”±
      const reasons: string[] = [];
      if (matchedIngs.length > 0) {
        const top3 = matchedIngs.slice(0, 3).join('ã€');
        reasons.push(`åŒ…å«å¸¸ç”¨åŸæ–™:${top3}`);
      }
      if (abvScore > 6) {
        reasons.push('é…’ç²¾åº¦æ¥è¿‘ä½ çš„åå¥½');
      }
      if (creatorBonus > 0) {
        reasons.push(`ä½ å¸¸çœ‹è°ƒé…’å¸ˆ:${r.createdBy}`);
      }
      if (popularityScore > 20) {
        reasons.push('è¾ƒå—æ¬¢è¿çš„é…æ–¹');
      }
      if (reasons.length === 0) {
        reasons.push('ä¸ºä½ æ¢ç´¢æ–°å£å‘³');
      }
      
      const item: ScoredItem = { recipe: r, score: score, reasons: reasons };
      scored.push(item);
    });
    
    // æ’åºå¹¶è½¬æ¢
    scored.sort((a, b) => b.score - a.score);
    const maxScore = scored.length > 0 ? scored[0].score : 1;
    
    return scored.map(item => {
      const pct = Math.min(100, Math.max(1, Math.round((item.score / maxScore) * 100)));
      const r = item.recipe;
      const ingredientsStr = this.extractIngredientNames(r.ingredients).join(', ');
      const result: ScoredRec = {
        id: r.id,
        name: r.name,
        createdBy: r.createdBy,
        estimatedAbv: r.estimatedAbv,
        matchPercentage: pct,
        reasons: item.reasons,
        likeCount: r.likeCount,
        favoriteCount: r.favoriteCount,
        ingredients: ingredientsStr,
        ingredientDetails: r.ingredients // ä¿ç•™è¯¦ç»†é…æ–™ä¿¡æ¯
      };
      return result;
    });
  }
  
  /**
   * è§£æé…æ–¹æ•°æ®
   */
  private parseRecipes(data: Array<object>): Recipe[] {
    console.info(`[RecommendationsPage] å¼€å§‹è§£æ ${data.length} ä¸ªé…æ–¹`);
    
    return data.map((item: ESObject): Recipe => {
      // å¤„ç† ingredients - å¯èƒ½æ˜¯æ•°ç»„æˆ–å­—ç¬¦ä¸²
      let ingredients: APIIngredient[] | undefined = undefined;
      const rawIngredients: ESObject = item['ingredients'];
      if (rawIngredients && Array.isArray(rawIngredients)) {
        ingredients = rawIngredients as APIIngredient[];
        console.info(`[RecommendationsPage] é…æ–¹ ${item['name']} æœ‰ ${ingredients.length} ä¸ªé…æ–™`);
      } else {
        console.info(`[RecommendationsPage] é…æ–¹ ${item['name']} æ²¡æœ‰é…æ–™æ•°ç»„, rawIngredients type: ${typeof rawIngredients}`);
      }
      
      return {
        id: (item['id'] || '') as string,
        name: (item['name'] || 'æœªå‘½å') as string,
        createdBy: (item['createdBy'] || item['created_by'] || 'æœªçŸ¥') as string,
        instructions: (item['instructions'] || '') as string,
        estimatedAbv: this.parseNumber(item['estimatedAbv'] || item['estimated_abv']),
        likeCount: this.parseNumber(item['likeCount'] || item['like_count']),
        favoriteCount: this.parseNumber(item['favoriteCount'] || item['favorite_count']),
        ingredients: ingredients
      };
    });
  }
  
  /**
   * ä»åŸæ–™æå–åŸæ–™åç§°åˆ—è¡¨
   * æ”¯æŒ: APIIngredient[] | string | undefined
   */
  private extractIngredientNames(ingredients: APIIngredient[] | undefined): string[] {
    if (!ingredients) return [];
    
    // ä½¿ç”¨ ESObject æ¥å¤„ç†å¯èƒ½çš„å­—ç¬¦ä¸²æˆ–æ•°ç»„ç±»å‹
    const ingsObj: ESObject = ingredients as ESObject;
    
    // å¦‚æœæ˜¯å­—ç¬¦ä¸²,åˆ†å‰²å¤„ç†
    if (typeof ingsObj === 'string') {
      const strIngs = ingsObj as string;
      if (strIngs.length === 0) return [];
      const parts: string[] = strIngs.split(/[,ï¼Œã€]/);
      const trimmed: string[] = parts.map((s: string): string => s.trim().toLowerCase());
      const filtered: string[] = trimmed.filter((s: string): boolean => s.length > 0);
      const cleaned: string[] = filtered.map((s: string): string => s.replace(/\(.*?\)/g, '').trim());
      return cleaned;
    }
    
    // å¦‚æœæ˜¯æ•°ç»„,ä»APIIngredientæå–name
    if (Array.isArray(ingsObj)) {
      const arrIngs = ingsObj as APIIngredient[];
      if (arrIngs.length === 0) return [];
      const names: string[] = arrIngs.map((ing: APIIngredient): string => ing.name.trim().toLowerCase());
      const filtered: string[] = names.filter((s: string): boolean => s.length > 0);
      const cleaned: string[] = filtered.map((s: string): string => s.replace(/\(.*?\)/g, '').trim());
      return cleaned;
    }
    
    return [];
  }
  
  /**
   * å®‰å…¨è§£ææ•°å€¼
   */
  private parseNumber(value: ESObject): number {
    if (value === null || value === undefined) return 0;
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
      const parsed = parseFloat(value as string);
      return isNaN(parsed) ? 0 : parsed;
    }
    const parsed = parseFloat(String(value));
    return isNaN(parsed) ? 0 : parsed;
  }
  
  /**
   * è·³è½¬åˆ°é…æ–¹è¯¦æƒ…
   */
  private navigateToDetail(rec: ScoredRec) {
    router.pushUrl({
      url: '@bundle:com.example.cybar/entry/ets/pages/RecipeDetailPage',
      params: {
        recipeId: rec.id
      }
    }).catch((error: Error) => {
      console.error('[RecommendationsPage] Navigation failed:', error);
      promptAction.showToast({ message: 'è·³è½¬å¤±è´¥' });
    });
  }
  
  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      Row() {
        Text('æ¨è')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .layoutWeight(1)
          .textAlign(TextAlign.Center)
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      
      // å†…å®¹åŒºåŸŸ
      if (this.hasError) {
        this.buildErrorState();
      } else if (this.isLoading) {
        this.buildLoadingState();
      } else if (this.recs.length === 0) {
        this.buildEmptyState();
      } else {
        this.buildRecommendationsList();
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F5F5F5')
  }
  
  /**
   * åŠ è½½çŠ¶æ€
   */
  @Builder
  buildLoadingState() {
    Column({ space: 16 }) {
      LoadingProgress()
        .width(50)
        .height(50)
        .color('#1890ff')
      
      Text('æ­£åœ¨ç”Ÿæˆä¸ªæ€§åŒ–æ¨è...')
        .fontSize(14)
        .fontColor('#999999')
    }
    .width('100%')
    .layoutWeight(1)
    .justifyContent(FlexAlign.Center)
  }
  
  /**
   * é”™è¯¯çŠ¶æ€
   */
  @Builder
  buildErrorState() {
    Column({ space: 16 }) {
      Text('âš ï¸')
        .fontSize(64)
        .opacity(0.3)
      
      Text(this.errorMessage || 'åŠ è½½å¤±è´¥')
        .fontSize(16)
        .fontColor('#FF3B30')
        .textAlign(TextAlign.Center)
      
      Button('é‡è¯•')
        .fontSize(14)
        .backgroundColor('#1890ff')
        .borderRadius(20)
        .padding({ left: 24, right: 24 })
        .margin({ top: 16 })
        .onClick(() => {
          this.loadRecommendations();
        })
    }
    .width('100%')
    .layoutWeight(1)
    .justifyContent(FlexAlign.Center)
    .padding(32)
  }
  
  /**
   * ç©ºçŠ¶æ€
   */
  @Builder
  buildEmptyState() {
    Column({ space: 16 }) {
      Text('âœ¨')
        .fontSize(64)
        .opacity(0.3)
      
      Text('æš‚æ— æ¨è')
        .fontSize(16)
        .fontColor('#999999')
        .textAlign(TextAlign.Center)
      
      Text('å»ç‚¹èµ/æ”¶è—ä¸€äº›é…æ–¹è¯•è¯•')
        .fontSize(14)
        .fontColor('#CCCCCC')
        .textAlign(TextAlign.Center)
        .margin({ top: 8 })
      
      Button('åˆ·æ–°')
        .fontSize(14)
        .backgroundColor('#1890ff')
        .borderRadius(20)
        .padding({ left: 24, right: 24 })
        .margin({ top: 16 })
        .onClick(() => {
          this.loadRecommendations();
        })
    }
    .width('100%')
    .layoutWeight(1)
    .justifyContent(FlexAlign.Center)
    .padding(32)
  }
  
  /**
   * æ¨èåˆ—è¡¨
   */
  @Builder
  buildRecommendationsList() {
    Refresh({ refreshing: $$this.isRefreshing }) {
      Scroll() {
        Column({ space: 12 }) {
          ForEach(this.recs, (rec: ScoredRec) => {
            this.buildRecommendationCard(rec)
          }, (rec: ScoredRec) => rec.id)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 12 })
      }
      .width('100%')
      .scrollBar(BarState.Auto)
      .edgeEffect(EdgeEffect.Spring)
    }
    .layoutWeight(1)
    .width('100%')
    .onRefreshing(async () => {
      await this.refreshRecommendations();
    })
  }
  
  /**
   * æ¨èå¡ç‰‡ - å•è¡Œå¸ƒå±€
   */
  @Builder
  buildRecommendationCard(rec: ScoredRec) {
    RecommendationCardComponent({ rec: rec })
  }
}

/**
 * æ¨èå¡ç‰‡ç»„ä»¶ - ç‹¬ç«‹çŠ¶æ€ç®¡ç†
 */
@Component
struct RecommendationCardComponent {
  @Prop rec: ScoredRec;
  @State displayIngredients: APIIngredient[] = [];
  @State isFetchingDetails: boolean = false;
  
  aboutToAppear() {
    // å°è¯•ä½¿ç”¨å·²æœ‰çš„é…æ–™æ•°æ®
    if (this.rec.ingredientDetails && this.rec.ingredientDetails.length > 0) {
      this.displayIngredients = this.rec.ingredientDetails;
      console.info(`[RecommendationCard] ä½¿ç”¨å·²æœ‰é…æ–™æ•°æ®: ${this.rec.name}, ${this.displayIngredients.length}ä¸ªé…æ–™`);
    } else {
      // æ‡’åŠ è½½é…æ–™è¯¦æƒ…
      console.info(`[RecommendationCard] æ‡’åŠ è½½é…æ–™è¯¦æƒ…: ${this.rec.name}`);
      this.fetchIngredientDetails();
    }
  }
  
  private async fetchIngredientDetails() {
    if (this.isFetchingDetails) return;
    
    this.isFetchingDetails = true;
    try {
      const apiService = APIService.getInstance();
      const detail = await apiService.fetchRecipeDetail(this.rec.id);
      
      if (detail && detail['ingredients']) {
        const rawIngs: ESObject = detail['ingredients'];
        if (Array.isArray(rawIngs)) {
          this.displayIngredients = rawIngs as APIIngredient[];
          console.info(`[RecommendationCard] è·å–åˆ°é…æ–™è¯¦æƒ…: ${this.displayIngredients.length}ä¸ª`);
        }
      }
    } catch (error) {
      console.error(`[RecommendationCard] è·å–é…æ–™è¯¦æƒ…å¤±è´¥:`, error);
    } finally {
      this.isFetchingDetails = false;
    }
  }
  
  private navigateToDetail() {
    router.pushUrl({
      url: '@bundle:com.example.cybar/entry/ets/pages/RecipeDetailPage',
      params: {
        recipeId: this.rec.id
      }
    }).catch((error: Error) => {
      console.error('[RecommendationCard] Navigation failed:', error);
      promptAction.showToast({ message: 'è·³è½¬å¤±è´¥' });
    });
  }
  
  build() {
    Column({ space: 12 }) {
      // é¡¶éƒ¨åŒºåŸŸ:åŒ¹é…åœ†åœˆ + åŸºæœ¬ä¿¡æ¯
      Row({ space: 16 }) {
        // å·¦ä¾§:åŒ¹é…åº¦åœ†ç¯
        this.buildMatchCircle(this.rec.matchPercentage)
        
        // å³ä¾§:é…æ–¹ä¿¡æ¯
        Column({ space: 6 }) {
          // é…æ–¹åç§°
          Text(this.rec.name)
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor('#1A1A1A')
            .maxLines(1)
            .textOverflow({ overflow: TextOverflow.Ellipsis })
          
          // åˆ›å»ºè€…å’ŒABV
          Row({ space: 12 }) {
            Text(`ğŸ‘¤ ${this.rec.createdBy}`)
              .fontSize(13)
              .fontColor('#666666')
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
              .layoutWeight(1)
            
            Text(`${this.rec.estimatedAbv.toFixed(1)}% ABV`)
              .fontSize(12)
              .fontColor('#1890ff')
              .fontWeight(FontWeight.Medium)
              .padding({ left: 10, right: 10, top: 4, bottom: 4 })
              .backgroundColor('rgba(24, 144, 255, 0.12)')
              .borderRadius(10)
          }
          .width('100%')
          
          // äº’åŠ¨æ•°æ®
          Row({ space: 16 }) {
            Text(`â¤ï¸ ${this.rec.likeCount}`)
              .fontSize(12)
              .fontColor('#999999')
            
            Text(`â­ ${this.rec.favoriteCount}`)
              .fontSize(12)
              .fontColor('#999999')
          }
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)
      }
      .width('100%')
      .alignItems(VerticalAlign.Top)
      
      // æ¨èç†ç”±
      if (this.rec.reasons.length > 0) {
        Column({ space: 6 }) {
          ForEach(this.rec.reasons, (reason: string) => {
            Row({ space: 8 }) {
              Text('âœ“')
                .fontSize(13)
                .fontColor('#52c41a')
                .fontWeight(FontWeight.Bold)
              
              Text(reason)
                .fontSize(13)
                .fontColor('#666666')
                .maxLines(1)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .layoutWeight(1)
            }
            .width('100%')
          }, (reason: string) => reason)
        }
        .width('100%')
        .padding({ top: 4 })
      }
      
      Divider()
        .color('#E8E8E8')
        .strokeWidth(1)
      
      // è¯¦ç»†é…æ–™ä¿¡æ¯
      Column({ space: 8 }) {
        Text('é…æ–™è¯¦æƒ…')
          .fontSize(14)
          .fontWeight(FontWeight.Medium)
          .fontColor('#333333')
        
        if (this.isFetchingDetails) {
          // åŠ è½½ä¸­çŠ¶æ€
          Row({ space: 8 }) {
            LoadingProgress()
              .width(16)
              .height(16)
              .color('#1890ff')
            Text('åŠ è½½é…æ–™ä¿¡æ¯...')
              .fontSize(12)
              .fontColor('#999999')
          }
          .padding(12)
        } else if (this.displayIngredients.length > 0) {
          Column({ space: 6 }) {
            ForEach(this.displayIngredients, (ing: APIIngredient) => {
              Row({ space: 10 }) {
                // é…æ–™åç§°
                Text(ing.name)
                  .fontSize(13)
                  .fontColor('#333333')
                  .layoutWeight(1)
                  .maxLines(1)
                  .textOverflow({ overflow: TextOverflow.Ellipsis })
                
                // ç”¨é‡å’ŒABV
                Row({ space: 8 }) {
                  Text(`${ing.volume}ml`)
                    .fontSize(12)
                    .fontColor('#666666')
                    .fontWeight(FontWeight.Medium)
                  
                  if (ing.abv > 0) {
                    Text(`${ing.abv}%`)
                      .fontSize(11)
                      .fontColor('#999999')
                      .padding({ left: 6, right: 6, top: 2, bottom: 2 })
                      .backgroundColor('#F5F5F5')
                      .borderRadius(6)
                  }
                }
              }
              .width('100%')
              .padding({ left: 8, right: 8, top: 6, bottom: 6 })
              .backgroundColor('#FAFAFA')
              .borderRadius(8)
            }, (ing: APIIngredient) => ing.id || ing.name)
          }
          .width('100%')
        } else {
          Text(this.rec.ingredients || 'æš‚æ— é…æ–™ä¿¡æ¯')
            .fontSize(13)
            .fontColor('#999999')
            .padding(8)
        }
      }
      .width('100%')
      .alignItems(HorizontalAlign.Start)
    }
    .width('100%')
    .padding(16)
    .backgroundColor(Color.White)
    .borderRadius(16)
    .shadow({
      radius: 12,
      color: '#00000015',
      offsetX: 0,
      offsetY: 4
    })
    .onClick(() => {
      this.navigateToDetail();
    })
  }
  
  /**
   * åŒ¹é…åº¦åœ†åœˆ - çœŸå®è¿›åº¦ç¯
   */
  @Builder
  buildMatchCircle(percentage: number) {
    Stack() {
      // ä½¿ç”¨ Progress ç»„ä»¶æ˜¾ç¤ºçœŸå®è¿›åº¦
      Progress({
        value: percentage,
        total: 100,
        type: ProgressType.Ring
      })
        .width(60)
        .height(60)
        .color('#52c41a')
        .backgroundColor('#F0F0F0')
        .style({
          strokeWidth: 6
        })
      
      // ä¸­å¿ƒæ–‡å­—
      Column({ space: 2 }) {
        Text(`${percentage}%`)
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .fontColor('#1A1A1A')
        
        Text('åŒ¹é…')
          .fontSize(10)
          .fontColor('#999999')
      }
    }
    .width(60)
    .height(60)
  }
}
