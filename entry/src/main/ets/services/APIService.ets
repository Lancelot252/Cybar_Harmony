// APIService.ets - APIæœåŠ¡å°è£…
// å¯¹åº” Swift é¡¹ç›®ä¸­çš„ APIService.swift

import { http } from '@kit.NetworkKit';
import { common } from '@kit.AbilityKit';
import preferences from '@ohos.data.preferences';
import { RecipesResponse, RecommendationsResponse } from '../models/Recipe';
import request from '@ohos.request';
import fs from '@ohos.file.fs';

interface AdminCommentsResponse {
  comments: AdminComment[];
  totalItems?: number;
}

// é€‚é…åç«¯ /api/recipes çš„è¿”å›ç»“æ„
interface AdminRecipesResponse {
  recipes: AdminRecipe[];
  totalPages?: number;
  currentPage?: number;
  sortBy?: string;
}

interface AdminUsersResponse {
  users: User[];
  totalItems: number;
  totalPages: number;
  currentPage: number;
}

// âœ… ä¿®æ­£ï¼šé€‚é… server/routes/admin.js è¿”å›çš„ { totalRecipes, totalUsers }
export interface AdminStats {
  totalUsers: number;
  totalRecipes: number;
}

// è‡ªå®šä¹‰é”™è¯¯ç±»
export class APIError extends Error {
  code: string;
  
  constructor(message: string, code: string = 'UNKNOWN') {
    super(message);
    this.code = code;
    this.name = 'APIError';
  }
}

export interface AdminUser {
  id: string;
  username: string;
  role: string;
  avatar: string;
  signature: string;
}

export interface AdminRecipe {
  id: string;
  name: string;
  createdBy: string;
  likeCount: number;
  favoriteCount: number;
  image?: string; // é…æ–¹å›¾ç‰‡è·¯å¾„
}

export interface AdminComment {
  id: string;
  user_name?: string;
  username: string;
  text: string;
  timestamp: string;
  recipeId?: string;
  recipeName?: string;
}

// APIå“åº”åŸºç¡€ç»“æ„
export interface APIResponse<T> {
  success?: boolean;
  message: string;
  data: T;
}

// ç”¨æˆ·ä¿¡æ¯
export interface User {
  id: string;
  username: string;
  role: string;
  avatar: string;
  signature: string;
}

// è®¤è¯çŠ¶æ€
export interface AuthStatus {
  loggedIn: boolean;
  username?: string;
  role?: string;
}

// ç™»å½•çŠ¶æ€ç¼“å­˜ç»“æ„
interface LoginCache {
  username: string;
  role: string;
  cachedAt: number;
  cookie?: string;
}

const LOGIN_CACHE_KEY = 'loginCache';
const LOGIN_CACHE_MAX_AGE_MS = 90 * 24 * 60 * 60 * 1000; // 90 å¤©

interface LoginResponseData {
  username?: string;
  role?: string;
  userRole?: string;
}

interface LoginResponseBody {
  message?: string;
  data?: LoginResponseData;
  username?: string;
  role?: string;
  userRole?: string;
}

interface LoginRequestBody {
  username: string;
  password: string;
}

interface CommentRequestBody {
  commentText: string;
}

interface UploadResult {
  success: boolean;
}

interface RequestHeaders {
  'Content-Type'?: string;
  Cookie?: string;
}

interface HeaderOptions {
  contentType?: string;
}

// æ›´æ–°é…æ–¹è¯·æ±‚ä½“ï¼ˆå‰ç«¯ JSON æ–¹å¼ï¼‰
interface UpdateRecipeRequestBody {
  name: string;
  description: string;
  estimatedAbv: string;
  ingredients: string; // JSON å­—ç¬¦ä¸²
  steps: string;       // JSON å­—ç¬¦ä¸²
  instructions: string;
}

// çŠ¶æ€å˜åŒ–ç›‘å¬å™¨ç±»å‹
type StateChangeListener = () => void;

// æ¨èç®—æ³•ç›¸å…³æ¥å£å®šä¹‰
interface UserInteraction {
  id: string;
  name: string;
  interactionType: 'like' | 'favorite';
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
}

interface UserPreferences {
  preferredAbv: number;
  topCreators: string[];
  ingredientWeights: Map<string, number>;
  interactedRecipeIds: Set<string>;
  avgRecipeWeight: number;
}

interface RecommendationScores {
  ingredientMatch: number;
  creatorMatch: number;
  abvMatch: number;
  popularity: number;
}

interface ScoredRecipe {
  id: string;
  name: string;
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
  likeCount: number;
  favoriteCount: number;
  scores: RecommendationScores;
  totalScore: number;
  matchReasons: string[];
}

// å®šä¹‰é…æ–¹æ•°æ®æ¥å£
interface RecipeData {
  id: string;
  name: string;
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
  likeCount: number;
  favoriteCount: number;
}

// æ¨èç»“æœæ¥å£
interface RecommendationResult {
  id: string;
  name: string;
  estimatedAbv: number;
  matchPercentage: number;
  reason: string;
  reasons: string[];
  likeCount: number;
}

// æœ¬åœ°é…æ–¹å“åº”æ¥å£
interface LocalRecipesResponse {
  recipes?: RecipeData[];
}

/**
 * ==================== ç¯å¢ƒé…ç½® ====================
 * åˆ‡æ¢ç¯å¢ƒï¼šæ³¨é‡Š/å–æ¶ˆæ³¨é‡Šä¸‹é¢çš„ BASE_URL å³å¯
 * =================================================
 */

// âš ï¸ å¼€å‘ç¯å¢ƒ - æœ¬åœ°è°ƒè¯•ï¼ˆä½¿ç”¨æ—¶å–æ¶ˆæ³¨é‡Šè¿™è¡Œï¼Œæ³¨é‡Šæ‰ç”Ÿäº§ç¯å¢ƒï¼‰
// const BASE_URL: string = 'http://172.26.19.215:8080';
// const BASE_URL: string = 'http://10.0.2.2:80';
// const BASE_URL: string = 'http://192.168.43.231:8080';
// âš ï¸ ç”Ÿäº§ç¯å¢ƒ - è¿œç¨‹æœåŠ¡å™¨ï¼ˆå‘å¸ƒæ—¶å–æ¶ˆæ³¨é‡Šè¿™è¡Œï¼Œæ³¨é‡Šæ‰å¼€å‘ç¯å¢ƒï¼‰
const BASE_URL: string = 'http://47.101.11.98:8080';

/**
 * APIæœåŠ¡å•ä¾‹ç±»
 * æä¾›ä¸åç«¯äº¤äº’çš„ç½‘ç»œæœåŠ¡
 * ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼é€šçŸ¥UIæ›´æ–°
 */
export default class APIService {
  private static instance: APIService;
  
  // ä½¿ç”¨é…ç½®çš„baseURL
  private baseURL: string = BASE_URL;
  private context?: common.UIAbilityContext;
  private preferences?: preferences.Preferences;
  private authCookie: string = '';
  private loginCache?: LoginCache;
  
  // å½“å‰ç™»å½•çŠ¶æ€ - ç§æœ‰,é€šè¿‡ getter è®¿é—®
  private _isLoggedIn: boolean = false;
  private _currentUser?: User;
  
  // çŠ¶æ€å˜åŒ–ç›‘å¬å™¨åˆ—è¡¨
  private listeners: StateChangeListener[] = [];
  
  // å…¬å¼€çš„ getter
  public get isLoggedIn(): boolean {
    return this._isLoggedIn;
  }
  
  public get currentUser(): User | undefined {
    return this._currentUser;
  }

  public get cachedLogin(): LoginCache | undefined {
    return this.loginCache;
  }

  // æš´éœ²åŸºç¡€åœ°å€ç”¨äºå‰ç«¯æ„é€ ç»å¯¹èµ„æº URL
  public getBaseURL(): string {
    return this.baseURL;
  }
  
  private constructor() {
    // ç§æœ‰æ„é€ å‡½æ•°,ç¡®ä¿å•ä¾‹æ¨¡å¼
  }
  
  /**
   * è·å–APIServiceå•ä¾‹
   */
  public static getInstance(): APIService {
    if (!APIService.instance) {
      console.info('[APIService] Creating new APIService instance');
      APIService.instance = new APIService();
      console.info(`[APIService] Instance created - baseURL: ${APIService.instance.baseURL}`);
    }
    return APIService.instance;
  }
  
  /**
   * æ·»åŠ çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public addListener(listener: StateChangeListener): void {
    this.listeners.push(listener);
  }
  
  /**
   * ç§»é™¤çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public removeListener(listener: StateChangeListener): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }
  
  /**
   * é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨çŠ¶æ€å·²å˜åŒ–
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => listener());
  }
  
  /**
   * æ›´æ–°ç™»å½•çŠ¶æ€å¹¶é€šçŸ¥ç›‘å¬å™¨
   */
  private updateLoginState(isLoggedIn: boolean, user?: User): void {
    this._isLoggedIn = isLoggedIn;
    this._currentUser = user;
    this.notifyListeners();
  }

  /**
   * æ„å»ºå¸¦æœ‰è®¤è¯ä¿¡æ¯çš„è¯·æ±‚å¤´
   */
  private buildAuthHeaders(options?: HeaderOptions): RequestHeaders | undefined {
    const hasCookie = this.authCookie && this.authCookie.length > 0;
    const hasContentType = options && options.contentType && options.contentType.length > 0;

    if (!hasCookie && !hasContentType) {
      return undefined;
    }

    if (hasCookie && hasContentType) {
      return {
        'Content-Type': (options as HeaderOptions).contentType!,
        Cookie: this.authCookie
      };
    }

    if (hasContentType) {
      return {
        'Content-Type': (options as HeaderOptions).contentType!
      };
    }

    return {
      Cookie: this.authCookie
    };
  }

  private createRequestOptions(
    method: http.RequestMethod,
    headerOptions?: HeaderOptions,
    body?: Object
  ): http.HttpRequestOptions {
    const headers = this.buildAuthHeaders(headerOptions);
    const options: http.HttpRequestOptions = {
      method: method,
      expectDataType: http.HttpDataType.OBJECT
    };

    if (headers) {
      options.header = headers;
    }

    if (body) {
      options.extraData = body;
    }

    return options;
  }

  /**
   * ä»å“åº”å¤´ä¸­æå–æœåŠ¡ç«¯ä¸‹å‘çš„ä¼šè¯ Cookie
   */
  private extractSessionCookie(response: http.HttpResponse): string | undefined {
    const headerObject: Object | undefined = response.header as Object;
    if (!headerObject) {
      return undefined;
    }

    const lowerCookie: ESObject = Reflect.get(headerObject, 'set-cookie') as ESObject;
    const upperCookie: ESObject = Reflect.get(headerObject, 'Set-Cookie') as ESObject;
    const normalized: ESObject = lowerCookie !== undefined ? lowerCookie : upperCookie;

    if (typeof normalized === 'string' && normalized.length > 0) {
      const parts = normalized.split(';');
      return parts.length > 0 ? parts[0] : normalized;
    }

    if (Array.isArray(normalized)) {
      const entries: Array<ESObject> = normalized as Array<ESObject>;
      const length = entries.length;
      for (let i = 0; i < length; i++) {
        const entry: ESObject = entries[i];
        if (typeof entry === 'string') {
          const entryStr: string = entry as string;
          if (entryStr.length > 0) {
            const parts = entryStr.split(';');
            return parts.length > 0 ? parts[0] : entryStr;
          }
        }
      }
    }

    return undefined;
  }
  
  /**
   * åˆå§‹åŒ–æœåŠ¡
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   */
  public async initialize(context: common.UIAbilityContext): Promise<void> {
    this.context = context;
    
    // åˆå§‹åŒ– preferences
    try {
      this.preferences = await preferences.getPreferences(context, 'apiservice');
    } catch (error) {
      console.error('[APIService] åˆå§‹åŒ– preferences å¤±è´¥:', error);
    }
    
    // æ¢å¤æœ¬åœ°ç™»å½•çŠ¶æ€ç¼“å­˜
    await this.restoreLoginFromCache();
    
    // æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
    await this.checkAuthStatus();
  }
  
  /**
   * ä»æœ¬åœ°ç¼“å­˜æ¢å¤ç™»å½•çŠ¶æ€
   */
  private async restoreLoginFromCache(): Promise<void> {
    if (!this.preferences) {
      return;
    }

    try {
      const cacheString = await this.preferences.get(LOGIN_CACHE_KEY, '') as string;
      if (!cacheString || cacheString.length === 0) {
        return;
      }

      const cache = JSON.parse(cacheString) as LoginCache | undefined;
      if (!cache) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      const now = Date.now();
      if (now - cache.cachedAt > LOGIN_CACHE_MAX_AGE_MS) {
        await this.clearLoginCache();
        return;
      }

      this.loginCache = cache;
      this.authCookie = cache.cookie ? cache.cookie : '';
      this.updateLoginState(true, {
        id: '',
        username: cache.username,
        role: cache.role,
        avatar: '',
        signature: ''
      });
    } catch (error) {
      console.error('[APIService] æ¢å¤ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }

  /**
   * æŒä¹…åŒ–ç™»å½•ç¼“å­˜
   */
  private async persistLoginCache(cache: LoginCache): Promise<void> {
    if (!this.preferences) {
      return;
    }

    try {
      this.loginCache = cache;
      this.authCookie = cache.cookie ? cache.cookie : '';
      await this.preferences.put(LOGIN_CACHE_KEY, JSON.stringify(cache));
      await this.preferences.flush();
    } catch (error) {
      console.error('[APIService] ä¿å­˜ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }

  /**
   * æ¸…é™¤ç™»å½•ç¼“å­˜
   */
  private async clearLoginCache(): Promise<void> {
    this.loginCache = undefined;
    this.authCookie = '';

    if (!this.preferences) {
      return;
    }

    try {
      await this.preferences.delete(LOGIN_CACHE_KEY);
      await this.preferences.flush();
    } catch (error) {
      console.error('[APIService] æ¸…é™¤ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }
  
  /**
   * æ£€æŸ¥è®¤è¯çŠ¶æ€
   */
  public async checkAuthStatus(): Promise<void> {
    try {
      const url = `${this.baseURL}/api/auth/status`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200 && response.result) {
        const authStatus = response.result as AuthStatus;
        
        if (authStatus.loggedIn && authStatus.username && authStatus.role) {
          const user: User = {
            id: '',
            username: authStatus.username,
            role: authStatus.role,
            avatar: '',
            signature: ''
          };
          const cookie = this.extractSessionCookie(response);
          if (cookie && cookie.length > 0) {
            this.authCookie = cookie;
          }

          const cacheFromStatus: LoginCache = {
            username: authStatus.username,
            role: authStatus.role,
            cachedAt: Date.now(),
            cookie: this.authCookie
          };
          await this.persistLoginCache(cacheFromStatus);
          this.updateLoginState(true, user);
        } else {
          this.updateLoginState(false, undefined);
          await this.clearLoginCache();
        }
      }
    } catch (error) {
      console.error('[APIService] æ£€æŸ¥è®¤è¯çŠ¶æ€å¤±è´¥:', error);
      if (!this.loginCache) {
        this.updateLoginState(false, undefined);
      }
    }
  }
  
  /**
   * ç”¨æˆ·ç™»å½•
   * @param username ç”¨æˆ·å
   * @param password å¯†ç 
   */
  public async login(username: string, password: string): Promise<string> {
    try {
      const url = `${this.baseURL}/api/login`;
      const requestBody: LoginRequestBody = {
        username: username,
        password: password
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result as LoginResponseBody | undefined;
        let resolvedUsername: string = username;
        let resolvedRole: string = '';
        let message: string = 'ç™»å½•æˆåŠŸ';

        if (result) {
          if (result.message && result.message.length > 0) {
            message = result.message;
          }

          let payload: LoginResponseData | undefined = undefined;
          if (result.data) {
            payload = result.data;
          } else {
            const fallbackPayload: LoginResponseData = {
              username: result.username,
              role: result.role,
              userRole: result.userRole
            };
            payload = fallbackPayload;
          }

          if (payload) {
            if (payload.username && payload.username.length > 0) {
              resolvedUsername = payload.username;
            }
            const roleCandidate = payload.role && payload.role.length > 0 ? payload.role : (payload.userRole ? payload.userRole : '');
            if (roleCandidate && roleCandidate.length > 0) {
              resolvedRole = roleCandidate;
            }
          }
        }

        const user: User = {
          id: '',
          username: resolvedUsername,
          role: resolvedRole,
          avatar: '',
          signature: ''
        };

        const cookie = this.extractSessionCookie(response);
        this.authCookie = cookie ? cookie : '';
        const cacheFromLogin: LoginCache = {
          username: user.username,
          role: user.role,
          cachedAt: Date.now(),
          cookie: this.authCookie
        };
        await this.persistLoginCache(cacheFromLogin);
        this.updateLoginState(true, user);

        return message;
      } else {
        const errorBody = response.result as LoginResponseBody | undefined;
        let message = 'ç™»å½•å¤±è´¥';
        if (errorBody && errorBody.message && errorBody.message.length > 0) {
          message = errorBody.message;
        }
        throw new APIError(message, 'LOGIN_FAILED');
      }
    } catch (error) {
      console.error('[APIService] ç™»å½•å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ç™»å½•è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * ç”¨æˆ·æ³¨å†Œ
   * @param username ç”¨æˆ·å
   * @param password å¯†ç 
   */
  public async register(username: string, password: string): Promise<string> {
    try {
      const url = `${this.baseURL}/api/register`;
      const requestBody: LoginRequestBody = {
        username: username,
        password: password
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 201) {
        return 'æ³¨å†ŒæˆåŠŸ';
      } else {
        const errorBody = response.result as LoginResponseBody | undefined;
        let message = 'æ³¨å†Œå¤±è´¥';
        if (errorBody && errorBody.message && errorBody.message.length > 0) {
          message = errorBody.message;
        }
        throw new APIError(message, 'REGISTER_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ³¨å†Œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ³¨å†Œè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * ç”¨æˆ·ç™»å‡º
   */
  public async logout(): Promise<void> {
    try {
      const url = `${this.baseURL}/api/logout`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      await http.createHttp().request(url, requestOptions);

      await this.clearLoginCache();
      this.authCookie = '';
      this.updateLoginState(false, undefined);
    } catch (error) {
      console.error('[APIService] ç™»å‡ºå¤±è´¥:', error);
      throw new APIError('ç™»å‡ºè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–é…æ–¹åˆ—è¡¨
   * @param page é¡µç 
   * @param limit æ¯é¡µæ•°é‡
   * @param search æœç´¢å…³é”®è¯
   * @param sort æ’åºæ–¹å¼
   */
  public async fetchRecipes(
    page: number = 1,
    limit: number = 10,
    search: string = '',
    sort: string = 'default'
  ): Promise<object> {
    const httpRequest = http.createHttp();
    
    try {
      const url = `${this.baseURL}/api/recipes?page=${page}&limit=${limit}&search=${encodeURIComponent(search)}&sort=${sort}`;
      console.info(`[APIService] fetchRecipes - URL: ${url}`);
      
      // é…ç½®è¯·æ±‚é€‰é¡¹ - ç¡®ä¿æ­£ç¡®çš„è¶…æ—¶å’Œæ•°æ®ç±»å‹
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.OBJECT,
        connectTimeout: 10000,  // 10ç§’è¿æ¥è¶…æ—¶
        readTimeout: 10000      // 10ç§’è¯»å–è¶…æ—¶
      };
      
      console.info(`[APIService] fetchRecipes - Sending request...`);
      const response = await httpRequest.request(url, requestOptions);
      
      console.info(`[APIService] fetchRecipes - Response code: ${response.responseCode}`);
      
      if (response.responseCode === 200) {
        const result = response.result as object;
        console.info(`[APIService] fetchRecipes - SUCCESS - Got ${Object.keys(result).length} keys`);
        
        const recipes = Reflect.get(result, 'recipes') as Array<object> | null;
        if (recipes && Array.isArray(recipes)) {
          console.info(`[APIService] fetchRecipes - Got ${recipes.length} recipes`);
        }
        
        return result;
      } else {
        console.error(`[APIService] fetchRecipes - HTTP Error ${response.responseCode}`);
        throw new APIError(`è·å–é…æ–¹åˆ—è¡¨å¤±è´¥ (${response.responseCode})`, 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] fetchRecipes - Exception:', error);
      
      if (error instanceof APIError) {
        throw error;
      }
      
      // å¤„ç†ç½‘ç»œé”™è¯¯
      throw new APIError('ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'NETWORK_ERROR');
    } finally {
      // æ¸…ç†HTTPè¿æ¥
      httpRequest.destroy();
    }
  }
  
  /**
   * è·å–é…æ–¹è¯¦æƒ…
   * @param id é…æ–¹ID
   * å¯¹åº” server.js: GET /api/recipes/:id
   */
  public async fetchRecipeDetail(id: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${id}`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('è·å–é…æ–¹è¯¦æƒ…å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–é…æ–¹è¯¦æƒ…å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–é…æ–¹è¯¦æƒ…è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }

  /**
   * è·å–é…æ–¹äº¤äº’çŠ¶æ€ (ç‚¹èµå’Œæ”¶è—)
   * @param recipeId é…æ–¹ID
   * å¯¹åº” server.js: GET /api/recipes/:id/interactions
   */
  public async fetchRecipeInteractionStatus(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/interactions`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('è·å–äº¤äº’çŠ¶æ€å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–äº¤äº’çŠ¶æ€å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–äº¤äº’çŠ¶æ€è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–æ¨èåˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µï¼‰- ç°è°ƒç”¨recipesæ¥å£å¹¶åœ¨æœ¬åœ°å®ç°æ¨èç®—æ³•
   * @param page é¡µç ï¼ˆä»1å¼€å§‹ï¼‰
   * @param limit æ¯é¡µæ•°é‡
   */
  public async fetchRecommendations(page: number = 1, limit: number = 10): Promise<RecommendationsResponse> {
    try {
      if (!this._isLoggedIn) {
        return {
          recommendations: [],
          message: 'è¯·å…ˆç™»å½•ä»¥è·å–ä¸ªæ€§åŒ–æ¨è'
        };
      }

      // 1. è·å–ç”¨æˆ·çš„ç‚¹èµå’Œæ”¶è—æ•°æ®
      const userInteractions = await this.getUserInteractions();
      if (userInteractions.length === 0) {
        return {
          recommendations: [],
          message: 'æ‚¨è¿˜æ²¡æœ‰ç‚¹èµæˆ–æ”¶è—ä»»ä½•é…æ–¹ï¼Œæ— æ³•ç”Ÿæˆæ¨è'
        };
      }

      // 2. åˆ†æç”¨æˆ·åå¥½
      const userPreferences = this.analyzeUserPreferences(userInteractions);

      // 3. è·å–æ‰€æœ‰å€™é€‰é…æ–¹ï¼ˆè°ƒç”¨recipesæ¥å£ï¼‰
      const allRecipesData: object = await this.getAllRecipes();
      const recipesResponse = allRecipesData as LocalRecipesResponse;
      if (!recipesResponse || !recipesResponse.recipes) {
        throw new APIError('è·å–é…æ–¹æ•°æ®å¤±è´¥', 'FETCH_FAILED');
      }

      // 4. è¿‡æ»¤æ‰ç”¨æˆ·å·²äº¤äº’çš„é…æ–¹
      const candidateRecipes: RecipeData[] = [];
      recipesResponse.recipes.forEach((recipe: RecipeData) => {
        if (!userPreferences.interactedRecipeIds.has(recipe.id)) {
          candidateRecipes.push(recipe);
        }
      });

      // 5. è®¡ç®—æ¨èå¾—åˆ†
      const scoredRecipes: ScoredRecipe[] = this.calculateRecommendationScores(candidateRecipes, userPreferences);

      // 6. æ’åºå¹¶åº”ç”¨åˆ†é¡µ
      scoredRecipes.sort((a: ScoredRecipe, b: ScoredRecipe) => b.totalScore - a.totalScore);
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginatedRecipes: ScoredRecipe[] = [];
      for (let i = startIndex; i < Math.min(endIndex, scoredRecipes.length); i++) {
        paginatedRecipes.push(scoredRecipes[i]);
      }

      // 7. æ ¼å¼åŒ–è¿”å›æ•°æ®
      const recommendations: RecommendationResult[] = [];
      paginatedRecipes.forEach((recipe: ScoredRecipe) => {
        recommendations.push(this.formatRecommendation(recipe));
      });

      console.info(`[APIService] æ¨èåŠ è½½æˆåŠŸ: ç¬¬${page}é¡µ, ${recommendations.length}æ¡`);
      return {
        recommendations,
        pagination: {
          currentPage: page,
          totalPages: Math.ceil(scoredRecipes.length / limit),
          totalRecommendations: scoredRecipes.length,
          limit: limit,
          hasMore: page < Math.ceil(scoredRecipes.length / limit)
        }
      };

    } catch (error) {
      console.error('[APIService] è·å–æ¨èåˆ—è¡¨å¤±è´¥:', error);
      return { recommendations: [], message: 'åŠ è½½å¤±è´¥' };
    }
  }

  /**
   * è·å–ç”¨æˆ·äº¤äº’æ•°æ®ï¼ˆç‚¹èµå’Œæ”¶è—ï¼‰
   */
  private async getUserInteractions(): Promise<UserInteraction[]> {
    const interactions: UserInteraction[] = [];
    
    try {
      // è·å–ç”¨æˆ·ç‚¹èµçš„é…æ–¹
      const likes: object[] = await this.fetchUserLikes();
      likes.forEach((recipe: object) => {
        const recipeData = recipe as RecipeData;
        interactions.push({
          id: recipeData.id || '',
          name: recipeData.name || '',
          interactionType: 'like',
          estimatedAbv: recipeData.estimatedAbv || 0,
          createdBy: recipeData.createdBy || '',
          ingredients: recipeData.ingredients || ''
        });
      });

      // è·å–ç”¨æˆ·æ”¶è—çš„é…æ–¹
      const favorites: object[] = await this.fetchUserFavorites();
      favorites.forEach((recipe: object) => {
        const recipeData = recipe as RecipeData;
        interactions.push({
          id: recipeData.id || '',
          name: recipeData.name || '',
          interactionType: 'favorite',
          estimatedAbv: recipeData.estimatedAbv || 0,
          createdBy: recipeData.createdBy || '',
          ingredients: recipeData.ingredients || ''
        });
      });

    } catch (error) {
      console.error('[APIService] è·å–ç”¨æˆ·äº¤äº’æ•°æ®å¤±è´¥:', error);
    }

    return interactions;
  }

  /**
   * åˆ†æç”¨æˆ·åå¥½
   */
  private analyzeUserPreferences(interactions: UserInteraction[]): UserPreferences {
    const preferences: UserPreferences = {
      preferredAbv: 0,
      topCreators: [],
      ingredientWeights: new Map(),
      interactedRecipeIds: new Set(),
      avgRecipeWeight: 1
    };

    // è®°å½•å·²äº¤äº’çš„é…æ–¹ID
    interactions.forEach(interaction => {
      preferences.interactedRecipeIds.add(interaction.id);
    });

    // è®¡ç®—åå¥½é…’ç²¾åº¦ï¼ˆä¸­ä½æ•°ï¼‰
    const abvList = interactions
      .filter(i => i.estimatedAbv > 0)
      .map(i => i.estimatedAbv)
      .sort((a, b) => a - b);
    
    if (abvList.length > 0) {
      const mid = Math.floor(abvList.length / 2);
      preferences.preferredAbv = abvList.length % 2 === 1
        ? abvList[mid]
        : (abvList[mid - 1] + abvList[mid]) / 2;
    }

    // ç»Ÿè®¡åˆ›å»ºè€…åå¥½
    const creatorMap = new Map<string, number>();
    interactions.forEach(interaction => {
      if (interaction.createdBy) {
        const count = creatorMap.get(interaction.createdBy) || 0;
        creatorMap.set(interaction.createdBy, count + 1);
      }
    });
    const creatorPairs: [string, number][] = [];
    creatorMap.forEach((count, creator) => {
      creatorPairs.push([creator, count]);
    });
    creatorPairs.sort((a: [string, number], b: [string, number]) => b[1] - a[1]);
    
    preferences.topCreators = [];
    for (let i = 0; i < Math.min(3, creatorPairs.length); i++) {
      preferences.topCreators.push(creatorPairs[i][0]);
    }

    // åˆ†æåŸæ–™åå¥½
    let totalWeight = 0;
    interactions.forEach(interaction => {
      const weight = interaction.interactionType === 'favorite' ? 2 : 1;
      totalWeight += weight;
      
      if (interaction.ingredients) {
        const ingredients = interaction.ingredients.split(',');
        ingredients.forEach(rawIng => {
          const ingredient = this.normalizeIngredient(rawIng.trim());
          const currentWeight = preferences.ingredientWeights.get(ingredient) || 0;
          preferences.ingredientWeights.set(ingredient, currentWeight + weight);
        });
      }
    });

    preferences.avgRecipeWeight = interactions.length > 0 ? totalWeight / interactions.length : 1;

    return preferences;
  }

  /**
   * è§„èŒƒåŒ–åŸæ–™åç§°
   */
  private normalizeIngredient(ingredient: string): string {
    const ingredientNormalizationMap: Record<string, string> = {
      "é‡‘é…’ (gin)": "é‡‘é…’",
      "gin": "é‡‘é…’",
      "ä¼ç‰¹åŠ  (vodka)": "ä¼ç‰¹åŠ ",
      "vodka": "ä¼ç‰¹åŠ ",
      "æœ—å§†é…’ (rum)": "æœ—å§†é…’",
      "rum": "æœ—å§†é…’",
      "é¾™èˆŒå…° (tequila)": "é¾™èˆŒå…°",
      "tequila": "é¾™èˆŒå…°",
      "å¨å£«å¿Œ (whiskey)": "å¨å£«å¿Œ",
      "whiskey": "å¨å£«å¿Œ",
      "whisky": "å¨å£«å¿Œ",
      "ç™½å…°åœ° (brandy)": "ç™½å…°åœ°",
      "brandy": "ç™½å…°åœ°",
      "åˆ©å£é…’ (liqueur)": "åˆ©å£é…’",
      "liqueur": "åˆ©å£é…’",
      "è‹¦ç²¾ (bitters)": "è‹¦ç²¾",
      "bitters": "è‹¦ç²¾",
      "è‹æ‰“æ°´ (soda)": "è‹æ‰“æ°´",
      "soda": "è‹æ‰“æ°´",
      "æ±¤åŠ›æ°´ (tonic)": "æ±¤åŠ›æ°´",
      "tonic": "æ±¤åŠ›æ°´",
      "æŸ æª¬æ± (lemon juice)": "æŸ æª¬æ±",
      "lemon juice": "æŸ æª¬æ±",
      "é’æŸ æ± (lime juice)": "é’æŸ æ±",
      "lime juice": "é’æŸ æ±"
    };

    const lowerIngredient = ingredient.toLowerCase().trim();
    const keys = Object.keys(ingredientNormalizationMap);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = ingredientNormalizationMap[key];
      if (lowerIngredient === key.toLowerCase()) {
        return value;
      }
    }
    return ingredient.replace(/\(.*?\)/g, '').trim();
  }

  /**
   * è·å–æ‰€æœ‰é…æ–¹æ•°æ®
   */
  private async getAllRecipes(): Promise<object> {
    try {
      // è·å–è¶³å¤Ÿå¤šçš„é…æ–¹ç”¨äºæ¨èè®¡ç®—ï¼Œè®¾ç½®è¾ƒå¤§çš„limit
      const response: object = await this.fetchRecipes(1, 1000, '', 'default');
      return response;
    } catch (error) {
      console.error('[APIService] è·å–æ‰€æœ‰é…æ–¹å¤±è´¥:', error);
      throw new APIError('è·å–é…æ–¹æ•°æ®å¤±è´¥', 'FETCH_FAILED');
    }
  }

  /**
   * è®¡ç®—æ¨èå¾—åˆ†
   */
  private calculateRecommendationScores(recipes: RecipeData[], preferences: UserPreferences): ScoredRecipe[] {
    const results: ScoredRecipe[] = [];
    
    recipes.forEach((recipe: RecipeData) => {
      const scores: RecommendationScores = {
        ingredientMatch: 0,
        creatorMatch: 0,
        abvMatch: 0,
        popularity: 0
      };
      const matchReasons: string[] = [];

      // åŸæ–™åŒ¹é…å¾—åˆ† (æƒé‡ 4)
      if (recipe.ingredients) {
        const ingredientList: string[] = recipe.ingredients.split(',');
        const recipeIngredients: string[] = [];
        ingredientList.forEach((ing: string) => {
          recipeIngredients.push(this.normalizeIngredient(ing.trim()));
        });
        
        let rawIngredientScore = 0;
        recipeIngredients.forEach((ing: string) => {
          const weight = preferences.ingredientWeights.get(ing) || 0;
          rawIngredientScore += weight;
        });

        const smoothFactor = 0.5;
        scores.ingredientMatch = 4 * (rawIngredientScore / (preferences.avgRecipeWeight + smoothFactor));
        scores.ingredientMatch = Math.min(scores.ingredientMatch, 4);

        const commonIngredients: string[] = [];
        recipeIngredients.forEach((ing: string) => {
          if (preferences.ingredientWeights.has(ing)) {
            commonIngredients.push(ing);
          }
        });
        
        if (commonIngredients.length > 0) {
          const displayIngredients: string[] = [];
          for (let i = 0; i < Math.min(3, commonIngredients.length); i++) {
            displayIngredients.push(commonIngredients[i]);
          }
          const display = displayIngredients.join('ã€');
          matchReasons.push(`å¯èƒ½å–œæ¬¢çš„åŸæ–™: ${display}${commonIngredients.length > 3 ? 'ç­‰' : ''}`);
        }
      }

      // åˆ›å»ºè€…åŒ¹é…å¾—åˆ† (æƒé‡ 3)
      if (recipe.createdBy && preferences.topCreators.includes(recipe.createdBy)) {
        scores.creatorMatch = 3;
        matchReasons.push(`å¯èƒ½å–œæ¬¢çš„è°ƒé…’å¸ˆ: ${recipe.createdBy}`);
      }

      // é…’ç²¾åº¦åŒ¹é…å¾—åˆ† (æƒé‡ 2)
      if (preferences.preferredAbv > 0 && recipe.estimatedAbv > 0) {
        const diff = Math.abs(recipe.estimatedAbv - preferences.preferredAbv);
        scores.abvMatch = Math.max(0, 2 * (1 - diff / 20));
        if (scores.abvMatch > 1.0) {
          matchReasons.push(`å¯èƒ½å–œæ¬¢çš„é…’ç²¾æµ“åº¦: ${recipe.estimatedAbv}%`);
        }
      }

      // äººæ°”å¾—åˆ† (æƒé‡ 1.5)
      const totalInteractions = (recipe.likeCount || 0) + (recipe.favoriteCount || 0);
      if (totalInteractions > 0) {
        scores.popularity = Math.min(1.5, 1.5 * Math.log(1 + totalInteractions / 50));
        if (totalInteractions > 10) {
          matchReasons.push(`çƒ­é—¨é…æ–¹ (å·²æœ‰${totalInteractions}æ¬¡ğŸ‘&â­)`);
        }
      }

      const totalScore = scores.ingredientMatch + scores.creatorMatch + scores.abvMatch + scores.popularity;

      const scoredRecipe: ScoredRecipe = {
        id: recipe.id,
        name: recipe.name,
        estimatedAbv: recipe.estimatedAbv,
        createdBy: recipe.createdBy,
        ingredients: recipe.ingredients,
        likeCount: recipe.likeCount,
        favoriteCount: recipe.favoriteCount,
        scores: scores,
        totalScore: totalScore,
        matchReasons: matchReasons
      };
      
      results.push(scoredRecipe);
    });
    
    return results;
  }

  /**
   * æ ¼å¼åŒ–æ¨èç»“æœ
   */
  private formatRecommendation(recipe: ScoredRecipe): RecommendationResult {
    const maxPossibleScore = 4 + 3 + 2 + 1.5; // æ€»æƒé‡
    const matchPercentage = Math.min(100, Math.round((recipe.totalScore / maxPossibleScore) * 100));

    let reasons: string[] = [];
    for (let i = 0; i < Math.min(3, recipe.matchReasons.length); i++) {
      reasons.push(recipe.matchReasons[i]);
    }
    if (reasons.length === 0) {
      reasons = ['æ‚¨å¯èƒ½å–œæ¬¢çš„æ–°é…æ–¹'];
    }
    const reasonText = reasons.join(' â€¢ ');

    const result: RecommendationResult = {
      id: recipe.id,
      name: recipe.name,
      estimatedAbv: recipe.estimatedAbv,
      matchPercentage: matchPercentage,
      reason: reasonText,
      reasons: reasons,
      likeCount: recipe.likeCount || 0
    };

    return result;
  }
  
  /**
   * åˆ‡æ¢ç‚¹èµçŠ¶æ€
   * @param recipeId é…æ–¹ID
   */
  public async toggleLike(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/like`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('ç‚¹èµæ“ä½œå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] ç‚¹èµæ“ä½œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ç‚¹èµè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * åˆ‡æ¢æ”¶è—çŠ¶æ€
   * @param recipeId é…æ–¹ID
   */
  public async toggleFavorite(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/favorite`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('æ”¶è—æ“ä½œå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ”¶è—æ“ä½œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ”¶è—è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–è¯„è®ºåˆ—è¡¨
   * @param recipeId é…æ–¹ID
   */
  public async fetchComments(recipeId: string): Promise<Array<object>> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/comments`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as Array<object>;
      } else {
        throw new APIError('è·å–è¯„è®ºå¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–è¯„è®ºå¤±è´¥:', error);
      return [];
    }
  }
  
  /**
   * æ·»åŠ è¯„è®º
   * @param recipeId é…æ–¹ID
   * @param text è¯„è®ºå†…å®¹
   * å¯¹åº” server.js: POST /api/recipes/:id/comments
   */
  public async addComment(recipeId: string, text: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/comments`;
      const requestBody: CommentRequestBody = {
        commentText: text
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      // server.js è¿”å› 201 Created
      if (response.responseCode === 201 || response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('æ·»åŠ è¯„è®ºå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ·»åŠ è¯„è®ºå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ·»åŠ è¯„è®ºè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·æ”¶è—åˆ—è¡¨
   */
  public async fetchUserFavorites(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/favorites`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„ (æœåŠ¡å™¨ç›´æ¥è¿”å›æ•°ç»„çš„æƒ…å†µ)
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserFavorites: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼ { data: [...] }
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserFavorites: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserFavorites: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–æ”¶è—å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–æ”¶è—å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–æ”¶è—è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·åˆ›å»ºçš„é…æ–¹åˆ—è¡¨
   */
  public async fetchUserCreatedRecipes(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/created-recipes`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„ (æœåŠ¡å™¨ç›´æ¥è¿”å›æ•°ç»„çš„æƒ…å†µ)
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserCreatedRecipes: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼ { data: [...] }
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserCreatedRecipes: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserCreatedRecipes: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–é…æ–¹å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–é…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–é…æ–¹è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·ç‚¹èµåˆ—è¡¨
   */
  public async fetchUserLikes(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/likes`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserLikes: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserLikes: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserLikes: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–ç‚¹èµå¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–ç‚¹èµå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–ç‚¹èµè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * æ›´æ–°ç”¨æˆ·èµ„æ–™
   * @param nickname æ˜µç§°ï¼ˆå¯é€‰ï¼‰
   * @param bio ä¸ªäººç®€ä»‹ï¼ˆå¯é€‰ï¼‰
   */
  public async updateUserProfile(nickname?: string, bio?: string): Promise<void> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      // å½“å‰èµ„æ–™ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°
      const currentNickname: string = this._currentUser && this._currentUser.username ? this._currentUser.username : '';
      const currentSignature: string = this._currentUser && this._currentUser.signature ? this._currentUser.signature : '';
      const newNickname: string | undefined = nickname !== undefined ? nickname.trim() : undefined;
      const newSignature: string | undefined = bio !== undefined ? bio.trim() : undefined;

      // 1) æ˜µç§°æ›´æ–°ï¼ˆPUT /api/user/profileï¼‰- ä»…å½“å˜æ›´æ—¶è°ƒç”¨
      if (newNickname && newNickname.length > 0 && newNickname !== currentNickname) {
        interface UpdateProfileRequest { nickname: string; }
        const profileUrl = `${this.baseURL}/api/user/profile`;
        const profileBody: UpdateProfileRequest = { nickname: newNickname };
        const profileOptions = this.createRequestOptions(
          http.RequestMethod.PUT,
          { contentType: 'application/json' },
          profileBody
        );
        const profileResp = await http.createHttp().request(profileUrl, profileOptions);
        if (profileResp.responseCode !== 200) {
          // åç«¯å¯èƒ½è¿”å› 409ï¼ˆæ˜µç§°å·²è¢«ä½¿ç”¨ï¼‰æˆ–å…¶ä»–é”™è¯¯
          let message = 'æ›´æ–°æ˜µç§°å¤±è´¥';
          try {
            const resObj: object = typeof profileResp.result === 'string' ? JSON.parse(profileResp.result) as object : profileResp.result as object;
            const msg: string = Reflect.get(resObj, 'message') as string;
            if (msg && msg.length > 0) { message = msg; }
          } catch (_) {}
          throw new APIError(message, 'UPDATE_NICKNAME_FAILED');
        }
      }

      // 2) ç®€ä»‹ï¼ˆç­¾åï¼‰æ›´æ–°ï¼ˆPOST /api/user/signatureï¼‰- ä»…å½“å˜æ›´æ—¶è°ƒç”¨
      if (newSignature !== undefined && newSignature !== currentSignature) {
        interface UpdateSignatureRequest { signature: string; }
        const signatureUrl = `${this.baseURL}/api/user/signature`;
        const signatureBody: UpdateSignatureRequest = { signature: newSignature };
        const signatureOptions = this.createRequestOptions(
          http.RequestMethod.POST,
          { contentType: 'application/json' },
          signatureBody
        );
        const signatureResp = await http.createHttp().request(signatureUrl, signatureOptions);
        if (signatureResp.responseCode !== 200) {
          let message = 'æ›´æ–°ç®€ä»‹å¤±è´¥';
          try {
            const resObj: object = typeof signatureResp.result === 'string' ? JSON.parse(signatureResp.result) as object : signatureResp.result as object;
            const msg: string = Reflect.get(resObj, 'message') as string;
            if (msg && msg.length > 0) { message = msg; }
          } catch (_) {}
          throw new APIError(message, 'UPDATE_SIGNATURE_FAILED');
        }
      }

      console.info('[APIService] ç”¨æˆ·èµ„æ–™æ›´æ–°å®Œæˆ');
      this.notifyListeners();
    } catch (error) {
      console.error('[APIService] æ›´æ–°ç”¨æˆ·èµ„æ–™å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ›´æ–°ç”¨æˆ·èµ„æ–™è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }

  /**
   * å•ç‹¬æ›´æ–°ç”¨æˆ·ç­¾åï¼ˆç®€ä»‹ï¼‰
   */
  public async updateUserSignature(signature: string): Promise<void> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      interface UpdateSignatureRequest { signature: string; }
      const url = `${this.baseURL}/api/user/signature`;
      const body: UpdateSignatureRequest = { signature: signature };
      const options = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        body
      );
      const resp = await http.createHttp().request(url, options);
      if (resp.responseCode !== 200) {
        let message = 'æ›´æ–°ç®€ä»‹å¤±è´¥';
        try {
          const resObj: object = typeof resp.result === 'string' ? JSON.parse(resp.result) as object : resp.result as object;
          const msg: string = Reflect.get(resObj, 'message') as string;
          if (msg && msg.length > 0) { message = msg; }
        } catch (_) {}
        throw new APIError(message, 'UPDATE_SIGNATURE_FAILED');
      }
      this.notifyListeners();
    } catch (error) {
      console.error('[APIService] æ›´æ–°ç­¾åå¤±è´¥:', error);
      if (error instanceof APIError) { throw error; }
      throw new APIError('æ›´æ–°ç­¾åè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·èµ„æ–™è¯¦æƒ…
   */
  public async fetchUserProfile(): Promise<object> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/profile`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        console.info('[APIService] è·å–ç”¨æˆ·èµ„æ–™æˆåŠŸ');
        return result as object;
      } else {
        throw new APIError('è·å–ç”¨æˆ·èµ„æ–™å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–ç”¨æˆ·èµ„æ–™å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–ç”¨æˆ·èµ„æ–™è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–éšæœºé…æ–¹åˆ—è¡¨(ç”¨äºæ¨è)
   * @param limit æ•°é‡é™åˆ¶
   */
  public async fetchRandomRecipes(limit: number = 100): Promise<Array<object>> {
    try {
      console.info(`[APIService] è·å–éšæœºé…æ–¹, limit=${limit}`);
      // ä½¿ç”¨sort=randomè·å–éšæœºæ’åºçš„é…æ–¹
      const response = await this.fetchRecipes(1, limit, '', 'random');
      
      // ç±»å‹å®‰å…¨çš„è®¿é—®recipeså±æ€§
      const responseObj = response as RecipesResponse;
      if (responseObj && responseObj.recipes) {
        const recipes: Array<object> = responseObj.recipes;
        console.info(`[APIService] è·å–åˆ° ${recipes.length} ä¸ªéšæœºé…æ–¹`);
        return recipes;
      }
      
      console.warn('[APIService] fetchRandomRecipes: å“åº”æ ¼å¼å¼‚å¸¸');
      return [];
    } catch (error) {
      console.error('[APIService] è·å–éšæœºé…æ–¹å¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new APIError('è·å–éšæœºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  // TODO: æ·»åŠ æ›´å¤šAPIæ–¹æ³•
  // - åˆ›å»ºé…æ–¹
  // - åˆ é™¤é…æ–¹
  // - AIç”Ÿæˆé…æ–¹
  // - ç®¡ç†å‘˜ç›¸å…³æ¥å£
  
  /**
   * è·å–è‡ªå®šä¹‰é…æ–¹çš„åŸæ–™åˆ—è¡¨
   */
  public async fetchCustomIngredients(): Promise<object> {
    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}/api/custom/ingredients`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError(`è·å–åŸæ–™åˆ—è¡¨å¤±è´¥ (${response.responseCode})`, 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–åŸæ–™åˆ—è¡¨å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–åŸæ–™åˆ—è¡¨å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
  
  /**
   * åˆ›å»ºæ–°é…æ–¹
   */
  public async createRecipe(recipeData: object): Promise<object> {
    if (!this.isLoggedIn) {
      throw new APIError('è¯·å…ˆç™»å½•', 'AUTH_REQUIRED');
    }

    const httpRequest = http.createHttp();
    try {
      // ä¸å¸¦å›¾æ¥å£ä¿æŒä¸€è‡´çš„è‡ªå®šä¹‰é…æ–¹ç«¯ç‚¹
      const url = `${this.baseURL}/api/custom/cocktails`;

      const name: string = Reflect.get(recipeData as ESObject, 'name') as string;
      const description: string = (Reflect.get(recipeData as ESObject, 'description') as string) || '';
      const estimatedAbvValue: ESObject = Reflect.get(recipeData as ESObject, 'estimatedAbv') as ESObject;
      const ingredientsValue: ESObject = Reflect.get(recipeData as ESObject, 'ingredients') as ESObject;
      const stepsValue: ESObject = Reflect.get(recipeData as ESObject, 'steps') as ESObject;
      const instructions: string = (Reflect.get(recipeData as ESObject, 'instructions') as string) || '';

      const body: UpdateRecipeRequestBody = {
        name: name,
        description: description,
        estimatedAbv: String(estimatedAbvValue),
        ingredients: JSON.stringify(ingredientsValue),
        steps: JSON.stringify(stepsValue || []),
        instructions: instructions
      };

      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        body
      );
      requestOptions.connectTimeout = 60000;
      requestOptions.readTimeout = 60000;

      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 201 || response.responseCode === 200) {
        console.info('[APIService] åˆ›å»ºé…æ–¹æˆåŠŸ (æ— å›¾)');
        if (typeof response.result === 'string') {
          return JSON.parse(response.result) as object;
        }
        return response.result as object;
      }
      throw new APIError(`åˆ›å»ºé…æ–¹å¤±è´¥ (${response.responseCode})`, 'CREATE_FAILED');
    } catch (error) {
      console.error('[APIService] åˆ›å»ºé…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('åˆ›å»ºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  // æ›´æ–°é…æ–¹ï¼ˆä¸å¸¦å›¾ç‰‡ï¼ŒJSONå­—æ®µå­—ç¬¦ä¸²åŒ–ä»¥å…¼å®¹åç«¯è§£æï¼‰
  public async updateRecipe(recipeId: string, recipeData: object): Promise<object> {
    try {
      const url = `${this.baseURL}/api/custom/cocktails/${recipeId}`;
      const name: string = Reflect.get(recipeData as ESObject, 'name') as string;
      const description: string = Reflect.get(recipeData as ESObject, 'description') as string;
      const estimatedAbvValue: ESObject = Reflect.get(recipeData as ESObject, 'estimatedAbv') as ESObject;
      const ingredientsValue: ESObject = Reflect.get(recipeData as ESObject, 'ingredients') as ESObject;
      const stepsValue: ESObject = Reflect.get(recipeData as ESObject, 'steps') as ESObject;
      const instructions: string = Reflect.get(recipeData as ESObject, 'instructions') as string;

      const body: UpdateRecipeRequestBody = {
        name: name,
        description: description || '',
        estimatedAbv: String(estimatedAbvValue),
        ingredients: JSON.stringify(ingredientsValue),
        steps: JSON.stringify(stepsValue || []),
        instructions: instructions || ''
      };

      const options = this.createRequestOptions(http.RequestMethod.PUT, { contentType: 'application/json' }, body);
      options.readTimeout = 60000;
      options.connectTimeout = 60000;
      const response = await http.createHttp().request(url, options);
      if (response.responseCode === 200) {
        return typeof response.result === 'string' ? JSON.parse(response.result) : response.result;
      }
      throw new APIError('æ›´æ–°é…æ–¹å¤±è´¥');
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new APIError('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
    }
  }

  // æ›´æ–°é…æ–¹ï¼ˆå¸¦å›¾ç‰‡ï¼Œmultipartï¼‰
  public async updateRecipeWithImage(context: common.UIAbilityContext, recipeId: string, recipeData: object, imagePath: string, imageFileName: string): Promise<object> {
    try {
      // ä½¿ç”¨ POST + method override ä»¥è§„é¿ RequestKit å¯¹ PUT çš„ä¸Šä¼ é™åˆ¶
      const url = `${this.baseURL}/api/custom/cocktails/${recipeId}?_method=PUT`;
      const internalUri = `internal://cache/${imageFileName}`;
      console.info(`[APIService] æ›´æ–°é…æ–¹å›¾ç‰‡: absolute=${imagePath}, internal=${internalUri}`);

      const files: Array<request.File> = [{
        filename: 'image.jpg',
        name: 'image',
        uri: internalUri,
        type: 'image/jpeg'
      }];

      const data: Array<request.RequestData> = [
        { name: 'name', value: Reflect.get(recipeData as ESObject, 'name') as string },
        { name: 'description', value: (Reflect.get(recipeData as ESObject, 'description') as string) || '' },
        { name: 'estimatedAbv', value: String(Reflect.get(recipeData as ESObject, 'estimatedAbv')) },
        { name: 'ingredients', value: JSON.stringify(Reflect.get(recipeData as ESObject, 'ingredients')) },
        { name: 'steps', value: JSON.stringify(Reflect.get(recipeData as ESObject, 'steps') || []) },
        { name: 'instructions', value: (Reflect.get(recipeData as ESObject, 'instructions') as string) || '' }
      ];

      const uploadConfig: request.UploadConfig = {
        url: url,
        header: { 'Cookie': this.authCookie, 'X-HTTP-Method-Override': 'PUT' },
        method: 'POST',
        files: files,
        data: data
      };

      const uploadTask = await request.uploadFile(context, uploadConfig);
      return await new Promise<object>((resolve, reject) => {
        uploadTask.on('complete', (taskStates: Array<request.TaskState>) => {
          const result: UploadResult = { success: true };
          resolve(result);
        });
        uploadTask.on('fail', (taskStates: Array<request.TaskState>) => {
          reject(new APIError('æ›´æ–°å¤±è´¥', 'UPLOAD_FAILED'));
        });
      });
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new APIError('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
    }
  }
  
  /**
   * åˆ›å»ºå¸¦å›¾ç‰‡çš„é…æ–¹
   */
  public async createRecipeWithImage(context: common.UIAbilityContext, recipeData: object, imagePath: string, imageFileName: string): Promise<object> {
    if (!this.isLoggedIn) {
      throw new APIError('è¯·å…ˆç™»å½•', 'AUTH_REQUIRED');
    }
    
    try {
      const url = `${this.baseURL}/api/custom/cocktails`;
      
      // ä½¿ç”¨ internal://cache/ åè®®è·¯å¾„
      const internalUri = `internal://cache/${imageFileName}`;
      console.info('[APIService] ç»å¯¹è·¯å¾„:', imagePath);
      console.info('[APIService] Internal URI:', internalUri);
      
      // æ„å»ºmultipart/form-data
      const files: Array<request.File> = [{
        filename: 'image.jpg',
        name: 'image',
        uri: internalUri,
        type: 'image/jpeg'
      }];
      
      // å°†recipeDataå­—æ®µè½¬ä¸ºFormDataæ ¼å¼
      const data: Array<request.RequestData> = [
        { name: 'name', value: Reflect.get(recipeData, 'name') as string },
        { name: 'description', value: Reflect.get(recipeData, 'description') as string || '' },
        { name: 'estimatedAbv', value: String(Reflect.get(recipeData, 'estimatedAbv')) },
        { name: 'ingredients', value: JSON.stringify(Reflect.get(recipeData, 'ingredients')) },
        { name: 'steps', value: JSON.stringify(Reflect.get(recipeData, 'steps') || []) }
      ];
      
      const uploadConfig: request.UploadConfig = {
        url: url,
        header: { 'Cookie': this.authCookie },
        method: 'POST',
        files: files,
        data: data
      };
      
      const uploadTask = await request.uploadFile(context, uploadConfig);
      
      return new Promise<object>((resolve, reject) => {
        uploadTask.on('complete', (taskStates: Array<request.TaskState>) => {
          console.info('[APIService] å¸¦å›¾ç‰‡åˆ›å»ºé…æ–¹æˆåŠŸ');
          const result: UploadResult = { success: true };
          resolve(result);
        });
        
        uploadTask.on('fail', (taskStates: Array<request.TaskState>) => {
          console.error('[APIService] å¸¦å›¾ç‰‡åˆ›å»ºé…æ–¹å¤±è´¥');
          reject(new APIError('ä¸Šä¼ å¤±è´¥', 'UPLOAD_FAILED'));
        });
      });
      
    } catch (error) {
      console.error('[APIService] å¸¦å›¾ç‰‡åˆ›å»ºé…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('åˆ›å»ºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * AIæ™ºèƒ½è°ƒé…’å¸ˆ - æ ¹æ®å£å‘³æè¿°ç”Ÿæˆé…æ–¹
   * @param tasteDescription å£å‘³æè¿°
   * @param occasion é€‚ç”¨åœºåˆï¼ˆå¯é€‰ï¼‰
   * @param alcoholStrength é…’ç²¾å¼ºåº¦ï¼ˆå¯é€‰ï¼‰
   */
  public async generateAIRecipe(
    tasteDescription: string,
    occasion?: string,
    alcoholStrength?: string
  ): Promise<AIGeneratedRecipe> {
    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}/api/custom/generate-recipe`;
      
      const requestBody: AIRecipeRequest = {
        tasteDescription: tasteDescription
      };
      if (occasion && occasion.length > 0) {
        requestBody.occasion = occasion;
      }
      if (alcoholStrength && alcoholStrength.length > 0) {
        requestBody.alcoholStrength = alcoholStrength;
      }
      
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      
      // è®¾ç½®è¾ƒé•¿çš„è¶…æ—¶æ—¶é—´ï¼Œå› ä¸ºAIç”Ÿæˆéœ€è¦æ—¶é—´
      requestOptions.connectTimeout = 30000;
      requestOptions.readTimeout = 60000;
      
      console.info('[APIService] æ­£åœ¨è°ƒç”¨AIç”Ÿæˆé…æ–¹...');
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result as object;
        console.info('[APIService] AIé…æ–¹ç”ŸæˆæˆåŠŸ, result:', JSON.stringify(result));
        
        // æœåŠ¡ç«¯è¿”å›æ ¼å¼: { success: true, recipe: {...}, generatedAt: ... }
        const recipeData = Reflect.get(result, 'recipe') as AIGeneratedRecipe;
        if (recipeData) {
          return recipeData;
        }
        
        // å…¼å®¹ç›´æ¥è¿”å›é…æ–¹çš„æƒ…å†µ
        if (Reflect.has(result, 'name') && Reflect.has(result, 'ingredients')) {
          return result as AIGeneratedRecipe;
        }
        
        throw new APIError('AIè¿”å›æ•°æ®æ ¼å¼é”™è¯¯', 'PARSE_ERROR');
      } else {
        const errorResult = response.result as object;
        const message = Reflect.get(errorResult, 'message') as string;
        throw new APIError(message || 'AIç”Ÿæˆé…æ–¹å¤±è´¥', 'AI_GENERATE_FAILED');
      }
    } catch (error) {
      console.error('[APIService] AIç”Ÿæˆé…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('AIç”Ÿæˆé…æ–¹è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * è·å–é…æ–¹è¯„åˆ†ä¿¡æ¯
   */
  async fetchRecipeRatings(recipeId: string): Promise<RecipeRatingResponse> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ratings`;
    
    try {
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      console.info(`[APIService] è·å–AIåˆ†ææ•°æ®, URL: ${url}`);
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        let result: object;
        if (typeof response.result === 'string') {
          result = JSON.parse(response.result) as object;
        } else {
          result = response.result as object;
        }
        
        const aiAnalysis = Reflect.get(result, 'aiAnalysis') as string | undefined;
        console.info(`[APIService] AIåˆ†ææ•°æ®: ${aiAnalysis ? 'å·²æ‰¾åˆ°' : 'æ— æ•°æ®'}`);
        
        return {
          success: true,
          hasRating: Reflect.get(result, 'hasRating') as boolean,
          ratings: Reflect.get(result, 'ratings') as RecipeScores | undefined,
          calculatedScore: Reflect.get(result, 'calculatedScore') as number | undefined,
          aiAnalysis: aiAnalysis,
          ratedAt: Reflect.get(result, 'ratedAt') as string | undefined
        };
      }
      throw new APIError('è·å–è¯„åˆ†å¤±è´¥', 'FETCH_RATINGS_FAILED');
    } catch (error) {
      console.error('[APIService] è·å–è¯„åˆ†å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–è¯„åˆ†è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * ä¿å­˜é…æ–¹è¯„åˆ†
   */
  async saveRecipeRatings(recipeId: string, scores: RecipeScores, aiAnalysis?: string): Promise<object> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ratings`;
    
    try {
      const requestBody: SaveRatingsRequest = { scores: scores, aiAnalysis: aiAnalysis };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      }
      const errorResult = response.result as object;
      const message = Reflect.get(errorResult, 'message') as string;
      throw new APIError(message || 'ä¿å­˜è¯„åˆ†å¤±è´¥', 'SAVE_RATINGS_FAILED');
    } catch (error) {
      console.error('[APIService] ä¿å­˜è¯„åˆ†å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ä¿å­˜è¯„åˆ†è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * AIå£å‘³åˆ†æ
   */
  async analyzeRecipeFlavor(recipeId: string): Promise<AIAnalysisResponse> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ai-analyze`;
    
    try {
      const emptyBody: EmptyRequest = {};
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        emptyBody
      );
      requestOptions.connectTimeout = 30000;
      requestOptions.readTimeout = 60000;
      
      console.info(`[APIService] æ­£åœ¨è¿›è¡ŒAIå£å‘³åˆ†æ, URL: ${url}`);
      const response = await httpRequest.request(url, requestOptions);
      
      console.info(`[APIService] AIåˆ†æå“åº”ç : ${response.responseCode}`);
      
      if (response.responseCode === 200) {
        let result: object;
        if (typeof response.result === 'string') {
          result = JSON.parse(response.result) as object;
        } else {
          result = response.result as object;
        }
        return {
          success: true,
          analysis: Reflect.get(result, 'analysis') as string,
          analyzedAt: Reflect.get(result, 'analyzedAt') as string
        };
      }
      
      // è§£æé”™è¯¯å“åº”
      let errorMessage = 'AIåˆ†æå¤±è´¥';
      try {
        let errorResult: object;
        if (typeof response.result === 'string') {
          errorResult = JSON.parse(response.result) as object;
        } else {
          errorResult = response.result as object;
        }
        const msg = Reflect.get(errorResult, 'message') as string;
        if (msg) {
          errorMessage = msg;
        }
      } catch (parseError) {
        console.error('[APIService] è§£æé”™è¯¯å“åº”å¤±è´¥:', parseError);
      }
      console.error(`[APIService] AIåˆ†æå¤±è´¥: ${errorMessage}`);
      throw new APIError(errorMessage, 'AI_ANALYZE_FAILED');
    } catch (error) {
      console.error('[APIService] AIåˆ†æè¯·æ±‚å¼‚å¸¸:', error);
      if (error instanceof APIError) {
        throw error;
      }
      const errMsg = error instanceof Error ? error.message : 'AIåˆ†ææœåŠ¡æš‚æ—¶ä¸å¯ç”¨';
      throw new APIError(errMsg, 'AI_SERVICE_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
  
  public getFullImageUrl(relativePath: string | undefined): string {
    if (!relativePath) {
      return '';
    }
    if (relativePath.startsWith('http')) {
      return relativePath;
    }
    const base = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;
    const path = relativePath.startsWith('/') ? relativePath : '/' + relativePath;
    return `${base}${path}`;
  }
  
  public async fetchCurrentUser(): Promise<User> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('æœªç™»å½•', 'NOT_LOGGED_IN');
      }

      const url = `${this.baseURL}/api/user/current`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);

      if (response.responseCode === 200) {
        const userData = response.result as User;
        this._currentUser = userData;
        this.updateLoginState(true, userData);
        return userData;
      } else {
        throw new APIError('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] fetchCurrentUser failed:', error);
      if (error instanceof APIError) {
        throw error;
      } else if (error instanceof Error) {
        throw error;
      } else {
        throw new APIError('è·å–ç”¨æˆ·ä¿¡æ¯å‘ç”ŸæœªçŸ¥é”™è¯¯', 'UNKNOWN');
      }
    }
  }
  
  public async uploadAvatar(context: common.UIAbilityContext, filePath: string): Promise<boolean> {
    return new Promise(async (resolve, reject) => {
      try {
        if (!this._isLoggedIn) {
          reject(new APIError('æœªç™»å½•', 'NOT_LOGGED_IN'));
          return;
        }

        console.info(`[Upload Monitor] å¼€å§‹ä¸Šä¼ å¤´åƒ... æœ¬åœ°è·¯å¾„: ${filePath}`);

        let uploadConfig: request.UploadConfig = {
          url: `${this.baseURL}/api/user/avatar`,
          header: {
            'Cookie': this.authCookie,
            'Content-Type': 'multipart/form-data'
          },
          method: 'POST',
          files: [{
            filename: 'avatar.jpg',
            name: 'avatar',
            uri: `internal://cache/${filePath.split('/').pop()}`,
            type: 'image/jpeg'
          }],
          data: []
        };

        const uploadTask = await request.uploadFile(context, uploadConfig);

        uploadTask.on('complete', (taskStates) => {
          this.fetchCurrentUser().then((updatedUser) => {
            console.info('========== [Upload Monitor] ä¸Šä¼ æˆåŠŸæŠ¥å‘Š ==========');
            console.info(`[Monitor] ç”¨æˆ·å: ${updatedUser.username}`);
            console.info(`[Monitor] åŸå§‹Avatarå­—æ®µ: ${updatedUser.avatar}`);
            console.info(`[Monitor] æœ€ç»ˆæ˜¾ç¤ºURL: ${this.getFullImageUrl(updatedUser.avatar)}`);
            console.info('===================================================');
            resolve(true);
          }).catch((err: Error) => {
            console.warn(`[Upload Monitor] æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼Œä½†åˆ·æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥: ${JSON.stringify(err)}`);
            resolve(true);
          });
        });

        uploadTask.on('fail', (taskStates) => {
          console.error('[Upload Monitor] âŒ ä¸Šä¼ å¤±è´¥:', JSON.stringify(taskStates));
          reject(new APIError('ä¸Šä¼ å¤±è´¥', 'UPLOAD_FAILED'));
        });

      } catch (error) {
        console.error('[Upload Monitor] åˆ›å»ºä¸Šä¼ ä»»åŠ¡å‡ºé”™:', error);
        reject(error);
      }
    });
  }
  
  public async put(path: string, data: object): Promise<object> {
    if (!this.isLoggedIn) {
      throw new APIError('è¯·å…ˆç™»å½•', 'AUTH_REQUIRED');
    }

    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}${path}`;
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.PUT,
        { contentType: 'application/json' },
        data
      );

      console.info(`[APIService] æ­£åœ¨å‘é€ PUT è¯·æ±‚è‡³: ${url}`);
      const response = await httpRequest.request(url, requestOptions);

      if (response.responseCode === 200 || response.responseCode === 204) {
        console.info('[APIService] æ•°æ®æ›´æ–°æˆåŠŸ');
        return response.result as object;
      } else {
        throw new APIError(`æ›´æ–°å¤±è´¥ (çŠ¶æ€ç : ${response.responseCode})`, 'UPDATE_FAILED');
      }
    } catch (error) {
      console.error('[APIService] PUT è¯·æ±‚å¼‚å¸¸:', error);
      if (error instanceof APIError) throw error;
      throw new APIError('æœåŠ¡å™¨æ›´æ–°è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
  
  public async getAdminStats(): Promise<AdminStats> {
    console.info('>>> æ­£åœ¨è°ƒç”¨ getAdminStats...');
    try {
      const url = `${this.baseURL}/api/admin/stats`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);

      console.info('è¿œç¨‹æœåŠ¡å™¨è¿”å›:', JSON.stringify(response.result));

      if (response.responseCode === 200) {
        return response.result as AdminStats;
      }
      throw new APIError('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥');
    } catch (error) {
      if (error instanceof Error) { throw error; }
      else { throw new APIError('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error)); }
    }
  }

  public async getAllUsers(): Promise<User[]> {
    try {
      const url = `${this.baseURL}/api/admin/users?limit=100`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);

      if (response.responseCode === 200) {
        const res: AdminUsersResponse = (typeof response.result === 'string' ? JSON.parse(response.result) : response.result) as AdminUsersResponse;
        console.info('[APIService] Adminç”¨æˆ·åˆ—è¡¨åŸå§‹æ•°æ®:', JSON.stringify(res.users[0]));
        if (res.users && Array.isArray(res.users)) {
          return res.users;
        }
        return [];
      }
      throw new APIError('è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥');
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new APIError('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  public async deleteUser(userId: string): Promise<boolean> {
    try {
      const url = `${this.baseURL}/api/admin/users/${userId}`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.DELETE);
      const response = await http.createHttp().request(url, requestOptions);

      return response.responseCode === 200;
    } catch (error) {
      console.error('Delete user failed:', error);
      return false;
    }
  }

  public async getAllRecipesForAdmin(): Promise<AdminRecipe[]> {
    try {
      const url = `${this.baseURL}/api/recipes?limit=100`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);

      if (response.responseCode === 200) {
        const res = (typeof response.result === 'string' ? JSON.parse(response.result) : response.result) as AdminRecipesResponse;

        if (res.recipes && Array.isArray(res.recipes)) {
          return res.recipes;
        }
        return [];
      }
      throw new APIError('è·å–é…æ–¹åˆ—è¡¨å¤±è´¥');
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new APIError('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  public async deleteRecipe(recipeId: string): Promise<boolean> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.DELETE);
      const response = await http.createHttp().request(url, requestOptions);

      return response.responseCode === 200;
    } catch (error) {
      console.error('Delete recipe failed:', error);
      return false;
    }
  }
  
  public async getAdminComments(): Promise<AdminComment[]> {
    try {
      const url = `${this.baseURL}/api/admin/comments?limit=100`;
      const response = await http.createHttp().request(url, this.createRequestOptions(http.RequestMethod.GET));

      if (response.responseCode === 200) {
        const res = (typeof response.result === 'string' ? JSON.parse(response.result) : response.result) as AdminCommentsResponse;

        if (res.comments && Array.isArray(res.comments)) {
          return res.comments;
        }
        return [];
      }
      return [];
    } catch (error) {
      return [];
    }
  }

  public async deleteComment(commentId: string): Promise<boolean> {
    try {
      const url = `${this.baseURL}/api/comments/${commentId}`;
      const response = await http.createHttp().request(url, this.createRequestOptions(http.RequestMethod.DELETE));
      return response.responseCode === 200;
    } catch (e) { return false; }
  }
}

// è¯„åˆ†å“åº”æ¥å£
export interface RecipeRatingResponse {
  success: boolean;
  hasRating: boolean;
  ratings?: RecipeScores;
  calculatedScore?: number;
  aiAnalysis?: string;
  ratedAt?: string;
}

// è¯„åˆ†æ•°æ®æ¥å£
export interface RecipeScores {
  visual: number;      // å¤–è§‚ (0-10)
  aroma: number;       // é¦™æ°” (0-10)
  taste: number;       // é£å‘³ (0-10)
  mouthfeel: number;   // å£æ„Ÿ (0-10)
  finish: number;      // ä½™éŸµ (0-10)
}

// AIåˆ†æå“åº”æ¥å£
export interface AIAnalysisResponse {
  success: boolean;
  analysis: string;
  analyzedAt: string;
}

// ä¿å­˜è¯„åˆ†è¯·æ±‚ä½“æ¥å£
interface SaveRatingsRequest {
  scores: RecipeScores;
  aiAnalysis?: string;
}

// ç©ºè¯·æ±‚ä½“æ¥å£
interface EmptyRequest {
  placeholder?: string;
}

// AIé…æ–¹è¯·æ±‚æ¥å£
interface AIRecipeRequest {
  tasteDescription: string;
  occasion?: string;
  alcoholStrength?: string;
}

// AIç”Ÿæˆçš„é…æ–¹æ¥å£
export interface AIGeneratedRecipe {
  name: string;
  description: string;
  ingredients: AIIngredient[];
  steps: string[];
  glassware?: string;
  garnish?: string;
  taste_profile?: TasteProfile;
  tips?: string;
  isDemo?: boolean;
}

// AIé…æ–¹ä¸­çš„é…æ–™æ¥å£
export interface AIIngredient {
  name: string;
  volume: number;
  abv: number;
  category?: string;
}

// å£å‘³é…ç½®æ¥å£
interface TasteProfile {
  sweetness: string;
  sourness: string;
  bitterness: string;
  strength: string;
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export const apiService = APIService.getInstance();
