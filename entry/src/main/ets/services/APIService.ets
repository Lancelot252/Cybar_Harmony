// APIService.ets - APIæœåŠ¡å°è£…
// å¯¹åº” Swift é¡¹ç›®ä¸­çš„ APIService.swift

import { http } from '@kit.NetworkKit';
import { common } from '@kit.AbilityKit';
import preferences from '@ohos.data.preferences';
import { RecipesResponse, RecommendationsResponse } from '../models/Recipe';
import fs from '@ohos.file.fs';
import { util } from '@kit.ArkTS';
import { request } from '@kit.BasicServicesKit';
import { photoAccessHelper } from '@kit.MediaLibraryKit';


// è‡ªå®šä¹‰é”™è¯¯ç±»
export class APIError extends Error {
  code: string;
  
  constructor(message: string, code: string = 'UNKNOWN') {
    super(message);
    this.code = code;
    this.name = 'APIError';
  }
}

// APIå“åº”åŸºç¡€ç»“æ„
export interface APIResponse<T> {
  success?: boolean;
  message?: string;
  data?: T;
}

// ç”¨æˆ·ä¿¡æ¯
export interface User {
  id: string;
  username: string;
  role: string;
}

// è®¤è¯çŠ¶æ€
export interface AuthStatus {
  loggedIn: boolean;
  username?: string;
  role?: string;
}

// ç™»å½•çŠ¶æ€ç¼“å­˜ç»“æ„
interface LoginCache {
  username: string;
  role: string;
  cachedAt: number;
  cookie?: string;
}

const LOGIN_CACHE_KEY = 'loginCache';
const LOGIN_CACHE_MAX_AGE_MS = 90 * 24 * 60 * 60 * 1000; // 90 å¤©

interface LoginResponseData {
  username?: string;
  role?: string;
  userRole?: string;
}

interface LoginResponseBody {
  message?: string;
  data?: LoginResponseData;
  username?: string;
  role?: string;
  userRole?: string;
}

interface LoginRequestBody {
  username: string;
  password: string;
}

interface CommentRequestBody {
  commentText: string;
}

interface RequestHeaders {
  'Content-Type'?: string;
  Cookie?: string;
}

interface HeaderOptions {
  contentType?: string;
}

// çŠ¶æ€å˜åŒ–ç›‘å¬å™¨ç±»å‹
type StateChangeListener = () => void;

// æ¨èç®—æ³•ç›¸å…³æ¥å£å®šä¹‰
interface UserInteraction {
  id: string;
  name: string;
  interactionType: 'like' | 'favorite';
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
}

interface UserPreferences {
  preferredAbv: number;
  topCreators: string[];
  ingredientWeights: Map<string, number>;
  interactedRecipeIds: Set<string>;
  avgRecipeWeight: number;
}

interface RecommendationScores {
  ingredientMatch: number;
  creatorMatch: number;
  abvMatch: number;
  popularity: number;
}

interface ScoredRecipe {
  id: string;
  name: string;
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
  likeCount: number;
  favoriteCount: number;
  scores: RecommendationScores;
  totalScore: number;
  matchReasons: string[];
}

// å®šä¹‰é…æ–¹æ•°æ®æ¥å£
interface RecipeData {
  id: string;
  name: string;
  estimatedAbv: number;
  createdBy: string;
  ingredients: string;
  likeCount: number;
  favoriteCount: number;
}

// æ¨èç»“æœæ¥å£
interface RecommendationResult {
  id: string;
  name: string;
  estimatedAbv: number;
  matchPercentage: number;
  reason: string;
  reasons: string[];
  likeCount: number;
}

// æœ¬åœ°é…æ–¹å“åº”æ¥å£
interface LocalRecipesResponse {
  recipes?: RecipeData[];
}

/**
 * ==================== ç¯å¢ƒé…ç½® ====================
 * åˆ‡æ¢ç¯å¢ƒï¼šæ³¨é‡Š/å–æ¶ˆæ³¨é‡Šä¸‹é¢çš„ BASE_URL å³å¯
 * =================================================
 */

// âš ï¸ å¼€å‘ç¯å¢ƒ - æœ¬åœ°è°ƒè¯•ï¼ˆä½¿ç”¨æ—¶å–æ¶ˆæ³¨é‡Šè¿™è¡Œï¼Œæ³¨é‡Šæ‰ç”Ÿäº§ç¯å¢ƒï¼‰
const BASE_URL: string = 'http://192.168.43.96:8080';
// const BASE_URL: string = 'http://10.0.2.2:80';
// const BASE_URL: string = 'http://192.168.43.231:8080';
// âš ï¸ ç”Ÿäº§ç¯å¢ƒ - è¿œç¨‹æœåŠ¡å™¨ï¼ˆå‘å¸ƒæ—¶å–æ¶ˆæ³¨é‡Šè¿™è¡Œï¼Œæ³¨é‡Šæ‰å¼€å‘ç¯å¢ƒï¼‰
// const BASE_URL: string = 'http://47.101.11.98:8080';

/**
 * APIæœåŠ¡å•ä¾‹ç±»
 * æä¾›ä¸åç«¯äº¤äº’çš„ç½‘ç»œæœåŠ¡
 * ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼é€šçŸ¥UIæ›´æ–°
 */
export default class APIService {
  private static instance: APIService;
  
  // ä½¿ç”¨é…ç½®çš„baseURL
  private baseURL: string = BASE_URL;
  private context?: common.UIAbilityContext;
  private preferences?: preferences.Preferences;
  private authCookie: string = '';
  private loginCache?: LoginCache;
  
  // å½“å‰ç™»å½•çŠ¶æ€ - ç§æœ‰,é€šè¿‡ getter è®¿é—®
  private _isLoggedIn: boolean = false;
  private _currentUser?: User;
  
  // çŠ¶æ€å˜åŒ–ç›‘å¬å™¨åˆ—è¡¨
  private listeners: StateChangeListener[] = [];
  
  // å…¬å¼€çš„ getter
  public get isLoggedIn(): boolean {
    return this._isLoggedIn;
  }
  
  public get currentUser(): User | undefined {
    return this._currentUser;
  }

  public get cachedLogin(): LoginCache | undefined {
    return this.loginCache;
  }

  // å…¬å¼€ baseURL ç”¨äºæ„å»ºå›¾ç‰‡URL
  public get baseUrl(): string {
    return this.baseURL;
  }
  
  private constructor() {
    // ç§æœ‰æ„é€ å‡½æ•°,ç¡®ä¿å•ä¾‹æ¨¡å¼
  }
  
  /**
   * è·å–APIServiceå•ä¾‹
   */
  public static getInstance(): APIService {
    if (!APIService.instance) {
      console.info('[APIService] Creating new APIService instance');
      APIService.instance = new APIService();
      console.info(`[APIService] Instance created - baseURL: ${APIService.instance.baseURL}`);
    }
    return APIService.instance;
  }
  
  /**
   * æ·»åŠ çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public addListener(listener: StateChangeListener): void {
    this.listeners.push(listener);
  }
  
  /**
   * ç§»é™¤çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
   */
  public removeListener(listener: StateChangeListener): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }
  
  /**
   * é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨çŠ¶æ€å·²å˜åŒ–
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => listener());
  }
  
  /**
   * æ›´æ–°ç™»å½•çŠ¶æ€å¹¶é€šçŸ¥ç›‘å¬å™¨
   */
  private updateLoginState(isLoggedIn: boolean, user?: User): void {
    this._isLoggedIn = isLoggedIn;
    this._currentUser = user;
    this.notifyListeners();
  }

  /**
   * æ„å»ºå¸¦æœ‰è®¤è¯ä¿¡æ¯çš„è¯·æ±‚å¤´
   */
  private buildAuthHeaders(options?: HeaderOptions): RequestHeaders | undefined {
    const hasCookie = this.authCookie && this.authCookie.length > 0;
    const hasContentType = options && options.contentType && options.contentType.length > 0;

    if (!hasCookie && !hasContentType) {
      return undefined;
    }

    if (hasCookie && hasContentType) {
      return {
        'Content-Type': (options as HeaderOptions).contentType!,
        Cookie: this.authCookie
      };
    }

    if (hasContentType) {
      return {
        'Content-Type': (options as HeaderOptions).contentType!
      };
    }

    return {
      Cookie: this.authCookie
    };
  }

  private createRequestOptions(
    method: http.RequestMethod,
    headerOptions?: HeaderOptions,
    body?: Object
  ): http.HttpRequestOptions {
    const headers = this.buildAuthHeaders(headerOptions);
    const options: http.HttpRequestOptions = {
      method: method,
      expectDataType: http.HttpDataType.OBJECT
    };

    if (headers) {
      options.header = headers;
    }

    if (body) {
      options.extraData = body;
    }

    return options;
  }

  /**
   * ä»å“åº”å¤´ä¸­æå–æœåŠ¡ç«¯ä¸‹å‘çš„ä¼šè¯ Cookie
   */
  private extractSessionCookie(response: http.HttpResponse): string | undefined {
    const headerObject: Object | undefined = response.header as Object;
    if (!headerObject) {
      return undefined;
    }

    const lowerCookie: ESObject = Reflect.get(headerObject, 'set-cookie') as ESObject;
    const upperCookie: ESObject = Reflect.get(headerObject, 'Set-Cookie') as ESObject;
    const normalized: ESObject = lowerCookie !== undefined ? lowerCookie : upperCookie;

    if (typeof normalized === 'string' && normalized.length > 0) {
      const parts = normalized.split(';');
      return parts.length > 0 ? parts[0] : normalized;
    }

    if (Array.isArray(normalized)) {
      const entries: Array<ESObject> = normalized as Array<ESObject>;
      const length = entries.length;
      for (let i = 0; i < length; i++) {
        const entry: ESObject = entries[i];
        if (typeof entry === 'string') {
          const entryStr: string = entry as string;
          if (entryStr.length > 0) {
            const parts = entryStr.split(';');
            return parts.length > 0 ? parts[0] : entryStr;
          }
        }
      }
    }

    return undefined;
  }
  
  /**
   * åˆå§‹åŒ–æœåŠ¡
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   */
  public async initialize(context: common.UIAbilityContext): Promise<void> {
    this.context = context;
    
    // åˆå§‹åŒ– preferences
    try {
      this.preferences = await preferences.getPreferences(context, 'apiservice');
    } catch (error) {
      console.error('[APIService] åˆå§‹åŒ– preferences å¤±è´¥:', error);
    }
    
    // æ¢å¤æœ¬åœ°ç™»å½•çŠ¶æ€ç¼“å­˜
    await this.restoreLoginFromCache();
    
    // æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
    await this.checkAuthStatus();
  }
  
  /**
   * ä»æœ¬åœ°ç¼“å­˜æ¢å¤ç™»å½•çŠ¶æ€
   */
  private async restoreLoginFromCache(): Promise<void> {
    if (!this.preferences) {
      return;
    }

    try {
      const cacheString = await this.preferences.get(LOGIN_CACHE_KEY, '') as string;
      if (!cacheString || cacheString.length === 0) {
        return;
      }

      const cache = JSON.parse(cacheString) as LoginCache | undefined;
      if (!cache) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      const now = Date.now();
      if (now - cache.cachedAt > LOGIN_CACHE_MAX_AGE_MS) {
        await this.clearLoginCache();
        return;
      }

      this.loginCache = cache;
      this.authCookie = cache.cookie ? cache.cookie : '';
      this.updateLoginState(true, {
        id: '',
        username: cache.username,
        role: cache.role
      });
    } catch (error) {
      console.error('[APIService] æ¢å¤ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }

  /**
   * æŒä¹…åŒ–ç™»å½•ç¼“å­˜
   */
  private async persistLoginCache(cache: LoginCache): Promise<void> {
    if (!this.preferences) {
      return;
    }

    try {
      this.loginCache = cache;
      this.authCookie = cache.cookie ? cache.cookie : '';
      await this.preferences.put(LOGIN_CACHE_KEY, JSON.stringify(cache));
      await this.preferences.flush();
    } catch (error) {
      console.error('[APIService] ä¿å­˜ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }

  /**
   * æ¸…é™¤ç™»å½•ç¼“å­˜
   */
  private async clearLoginCache(): Promise<void> {
    this.loginCache = undefined;
    this.authCookie = '';

    if (!this.preferences) {
      return;
    }

    try {
      await this.preferences.delete(LOGIN_CACHE_KEY);
      await this.preferences.flush();
    } catch (error) {
      console.error('[APIService] æ¸…é™¤ç™»å½•ç¼“å­˜å¤±è´¥:', error);
    }
  }
  
  /**
   * æ£€æŸ¥è®¤è¯çŠ¶æ€
   */
  public async checkAuthStatus(): Promise<void> {
    try {
      const url = `${this.baseURL}/api/auth/status`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200 && response.result) {
        const authStatus = response.result as AuthStatus;
        
        if (authStatus.loggedIn && authStatus.username && authStatus.role) {
          const user: User = {
            id: '',
            username: authStatus.username,
            role: authStatus.role
          };
          const cookie = this.extractSessionCookie(response);
          if (cookie && cookie.length > 0) {
            this.authCookie = cookie;
          }

          const cacheFromStatus: LoginCache = {
            username: authStatus.username,
            role: authStatus.role,
            cachedAt: Date.now(),
            cookie: this.authCookie
          };
          await this.persistLoginCache(cacheFromStatus);
          this.updateLoginState(true, user);
        } else {
          this.updateLoginState(false, undefined);
          await this.clearLoginCache();
        }
      }
    } catch (error) {
      console.error('[APIService] æ£€æŸ¥è®¤è¯çŠ¶æ€å¤±è´¥:', error);
      if (!this.loginCache) {
        this.updateLoginState(false, undefined);
      }
    }
  }
  
  /**
   * ç”¨æˆ·ç™»å½•
   * @param username ç”¨æˆ·å
   * @param password å¯†ç 
   */
  public async login(username: string, password: string): Promise<string> {
    try {
      const url = `${this.baseURL}/api/login`;
      const requestBody: LoginRequestBody = {
        username: username,
        password: password
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result as LoginResponseBody | undefined;
        let resolvedUsername: string = username;
        let resolvedRole: string = '';
        let message: string = 'ç™»å½•æˆåŠŸ';

        if (result) {
          if (result.message && result.message.length > 0) {
            message = result.message;
          }

          let payload: LoginResponseData | undefined = undefined;
          if (result.data) {
            payload = result.data;
          } else {
            const fallbackPayload: LoginResponseData = {
              username: result.username,
              role: result.role,
              userRole: result.userRole
            };
            payload = fallbackPayload;
          }

          if (payload) {
            if (payload.username && payload.username.length > 0) {
              resolvedUsername = payload.username;
            }
            const roleCandidate = payload.role && payload.role.length > 0 ? payload.role : (payload.userRole ? payload.userRole : '');
            if (roleCandidate && roleCandidate.length > 0) {
              resolvedRole = roleCandidate;
            }
          }
        }

        const user: User = {
          id: '',
          username: resolvedUsername,
          role: resolvedRole
        };

        const cookie = this.extractSessionCookie(response);
        this.authCookie = cookie ? cookie : '';
        const cacheFromLogin: LoginCache = {
          username: user.username,
          role: user.role,
          cachedAt: Date.now(),
          cookie: this.authCookie
        };
        await this.persistLoginCache(cacheFromLogin);
        this.updateLoginState(true, user);

        return message;
      } else {
        const errorBody = response.result as LoginResponseBody | undefined;
        let message = 'ç™»å½•å¤±è´¥';
        if (errorBody && errorBody.message && errorBody.message.length > 0) {
          message = errorBody.message;
        }
        throw new APIError(message, 'LOGIN_FAILED');
      }
    } catch (error) {
      console.error('[APIService] ç™»å½•å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ç™»å½•è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * ç”¨æˆ·æ³¨å†Œ
   * @param username ç”¨æˆ·å
   * @param password å¯†ç 
   */
  public async register(username: string, password: string): Promise<string> {
    try {
      const url = `${this.baseURL}/api/register`;
      const requestBody: LoginRequestBody = {
        username: username,
        password: password
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 201) {
        return 'æ³¨å†ŒæˆåŠŸ';
      } else {
        const errorBody = response.result as LoginResponseBody | undefined;
        let message = 'æ³¨å†Œå¤±è´¥';
        if (errorBody && errorBody.message && errorBody.message.length > 0) {
          message = errorBody.message;
        }
        throw new APIError(message, 'REGISTER_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ³¨å†Œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ³¨å†Œè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * ç”¨æˆ·ç™»å‡º
   */
  public async logout(): Promise<void> {
    try {
      const url = `${this.baseURL}/api/logout`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      await http.createHttp().request(url, requestOptions);

      await this.clearLoginCache();
      this.authCookie = '';
      this.updateLoginState(false, undefined);
    } catch (error) {
      console.error('[APIService] ç™»å‡ºå¤±è´¥:', error);
      throw new APIError('ç™»å‡ºè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–é…æ–¹åˆ—è¡¨
   * @param page é¡µç 
   * @param limit æ¯é¡µæ•°é‡
   * @param search æœç´¢å…³é”®è¯
   * @param sort æ’åºæ–¹å¼
   */
  public async fetchRecipes(
    page: number = 1,
    limit: number = 10,
    search: string = '',
    sort: string = 'default'
  ): Promise<object> {
    const httpRequest = http.createHttp();
    
    try {
      const url = `${this.baseURL}/api/recipes?page=${page}&limit=${limit}&search=${encodeURIComponent(search)}&sort=${sort}`;
      console.info(`[APIService] fetchRecipes - URL: ${url}`);
      
      // é…ç½®è¯·æ±‚é€‰é¡¹ - ç¡®ä¿æ­£ç¡®çš„è¶…æ—¶å’Œæ•°æ®ç±»å‹
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.GET,
        expectDataType: http.HttpDataType.OBJECT,
        connectTimeout: 10000,  // 10ç§’è¿æ¥è¶…æ—¶
        readTimeout: 10000      // 10ç§’è¯»å–è¶…æ—¶
      };
      
      console.info(`[APIService] fetchRecipes - Sending request...`);
      const response = await httpRequest.request(url, requestOptions);
      
      console.info(`[APIService] fetchRecipes - Response code: ${response.responseCode}`);
      
      if (response.responseCode === 200) {
        const result = response.result as object;
        console.info(`[APIService] fetchRecipes - SUCCESS - Got ${Object.keys(result).length} keys`);
        
        const recipes = Reflect.get(result, 'recipes') as Array<object> | null;
        if (recipes && Array.isArray(recipes)) {
          console.info(`[APIService] fetchRecipes - Got ${recipes.length} recipes`);
        }
        
        return result;
      } else {
        console.error(`[APIService] fetchRecipes - HTTP Error ${response.responseCode}`);
        throw new APIError(`è·å–é…æ–¹åˆ—è¡¨å¤±è´¥ (${response.responseCode})`, 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] fetchRecipes - Exception:', error);
      
      if (error instanceof APIError) {
        throw error;
      }
      
      // å¤„ç†ç½‘ç»œé”™è¯¯
      throw new APIError('ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'NETWORK_ERROR');
    } finally {
      // æ¸…ç†HTTPè¿æ¥
      httpRequest.destroy();
    }
  }
  
  /**
   * è·å–é…æ–¹è¯¦æƒ…
   * @param id é…æ–¹ID
   * å¯¹åº” server.js: GET /api/recipes/:id
   */
  public async fetchRecipeDetail(id: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${id}`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('è·å–é…æ–¹è¯¦æƒ…å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–é…æ–¹è¯¦æƒ…å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–é…æ–¹è¯¦æƒ…è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }

  /**
   * è·å–é…æ–¹äº¤äº’çŠ¶æ€ (ç‚¹èµå’Œæ”¶è—)
   * @param recipeId é…æ–¹ID
   * å¯¹åº” server.js: GET /api/recipes/:id/interactions
   */
  public async fetchRecipeInteractionStatus(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/interactions`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('è·å–äº¤äº’çŠ¶æ€å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–äº¤äº’çŠ¶æ€å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–äº¤äº’çŠ¶æ€è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–æ¨èåˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µï¼‰- ç°è°ƒç”¨recipesæ¥å£å¹¶åœ¨æœ¬åœ°å®ç°æ¨èç®—æ³•
   * @param page é¡µç ï¼ˆä»1å¼€å§‹ï¼‰
   * @param limit æ¯é¡µæ•°é‡
   */
  public async fetchRecommendations(page: number = 1, limit: number = 10): Promise<RecommendationsResponse> {
    try {
      if (!this._isLoggedIn) {
        return {
          recommendations: [],
          message: 'è¯·å…ˆç™»å½•ä»¥è·å–ä¸ªæ€§åŒ–æ¨è'
        };
      }

      // 1. è·å–ç”¨æˆ·çš„ç‚¹èµå’Œæ”¶è—æ•°æ®
      const userInteractions = await this.getUserInteractions();
      if (userInteractions.length === 0) {
        return {
          recommendations: [],
          message: 'æ‚¨è¿˜æ²¡æœ‰ç‚¹èµæˆ–æ”¶è—ä»»ä½•é…æ–¹ï¼Œæ— æ³•ç”Ÿæˆæ¨è'
        };
      }

      // 2. åˆ†æç”¨æˆ·åå¥½
      const userPreferences = this.analyzeUserPreferences(userInteractions);

      // 3. è·å–æ‰€æœ‰å€™é€‰é…æ–¹ï¼ˆè°ƒç”¨recipesæ¥å£ï¼‰
      const allRecipesData: object = await this.getAllRecipes();
      const recipesResponse = allRecipesData as LocalRecipesResponse;
      if (!recipesResponse || !recipesResponse.recipes) {
        throw new APIError('è·å–é…æ–¹æ•°æ®å¤±è´¥', 'FETCH_FAILED');
      }

      // 4. è¿‡æ»¤æ‰ç”¨æˆ·å·²äº¤äº’çš„é…æ–¹
      const candidateRecipes: RecipeData[] = [];
      recipesResponse.recipes.forEach((recipe: RecipeData) => {
        if (!userPreferences.interactedRecipeIds.has(recipe.id)) {
          candidateRecipes.push(recipe);
        }
      });

      // 5. è®¡ç®—æ¨èå¾—åˆ†
      const scoredRecipes: ScoredRecipe[] = this.calculateRecommendationScores(candidateRecipes, userPreferences);

      // 6. æ’åºå¹¶åº”ç”¨åˆ†é¡µ
      scoredRecipes.sort((a: ScoredRecipe, b: ScoredRecipe) => b.totalScore - a.totalScore);
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginatedRecipes: ScoredRecipe[] = [];
      for (let i = startIndex; i < Math.min(endIndex, scoredRecipes.length); i++) {
        paginatedRecipes.push(scoredRecipes[i]);
      }

      // 7. æ ¼å¼åŒ–è¿”å›æ•°æ®
      const recommendations: RecommendationResult[] = [];
      paginatedRecipes.forEach((recipe: ScoredRecipe) => {
        recommendations.push(this.formatRecommendation(recipe));
      });

      console.info(`[APIService] æ¨èåŠ è½½æˆåŠŸ: ç¬¬${page}é¡µ, ${recommendations.length}æ¡`);
      return {
        recommendations,
        pagination: {
          currentPage: page,
          totalPages: Math.ceil(scoredRecipes.length / limit),
          totalRecommendations: scoredRecipes.length,
          limit: limit,
          hasMore: page < Math.ceil(scoredRecipes.length / limit)
        }
      };

    } catch (error) {
      console.error('[APIService] è·å–æ¨èåˆ—è¡¨å¤±è´¥:', error);
      return { recommendations: [], message: 'åŠ è½½å¤±è´¥' };
    }
  }

  /**
   * è·å–ç”¨æˆ·äº¤äº’æ•°æ®ï¼ˆç‚¹èµå’Œæ”¶è—ï¼‰
   */
  private async getUserInteractions(): Promise<UserInteraction[]> {
    const interactions: UserInteraction[] = [];
    
    try {
      // è·å–ç”¨æˆ·ç‚¹èµçš„é…æ–¹
      const likes: object[] = await this.fetchUserLikes();
      likes.forEach((recipe: object) => {
        const recipeData = recipe as RecipeData;
        interactions.push({
          id: recipeData.id || '',
          name: recipeData.name || '',
          interactionType: 'like',
          estimatedAbv: recipeData.estimatedAbv || 0,
          createdBy: recipeData.createdBy || '',
          ingredients: recipeData.ingredients || ''
        });
      });

      // è·å–ç”¨æˆ·æ”¶è—çš„é…æ–¹
      const favorites: object[] = await this.fetchUserFavorites();
      favorites.forEach((recipe: object) => {
        const recipeData = recipe as RecipeData;
        interactions.push({
          id: recipeData.id || '',
          name: recipeData.name || '',
          interactionType: 'favorite',
          estimatedAbv: recipeData.estimatedAbv || 0,
          createdBy: recipeData.createdBy || '',
          ingredients: recipeData.ingredients || ''
        });
      });

    } catch (error) {
      console.error('[APIService] è·å–ç”¨æˆ·äº¤äº’æ•°æ®å¤±è´¥:', error);
    }

    return interactions;
  }

  /**
   * åˆ†æç”¨æˆ·åå¥½
   */
  private analyzeUserPreferences(interactions: UserInteraction[]): UserPreferences {
    const preferences: UserPreferences = {
      preferredAbv: 0,
      topCreators: [],
      ingredientWeights: new Map(),
      interactedRecipeIds: new Set(),
      avgRecipeWeight: 1
    };

    // è®°å½•å·²äº¤äº’çš„é…æ–¹ID
    interactions.forEach(interaction => {
      preferences.interactedRecipeIds.add(interaction.id);
    });

    // è®¡ç®—åå¥½é…’ç²¾åº¦ï¼ˆä¸­ä½æ•°ï¼‰
    const abvList = interactions
      .filter(i => i.estimatedAbv > 0)
      .map(i => i.estimatedAbv)
      .sort((a, b) => a - b);
    
    if (abvList.length > 0) {
      const mid = Math.floor(abvList.length / 2);
      preferences.preferredAbv = abvList.length % 2 === 1
        ? abvList[mid]
        : (abvList[mid - 1] + abvList[mid]) / 2;
    }

    // ç»Ÿè®¡åˆ›å»ºè€…åå¥½
    const creatorMap = new Map<string, number>();
    interactions.forEach(interaction => {
      if (interaction.createdBy) {
        const count = creatorMap.get(interaction.createdBy) || 0;
        creatorMap.set(interaction.createdBy, count + 1);
      }
    });
    const creatorPairs: [string, number][] = [];
    creatorMap.forEach((count, creator) => {
      creatorPairs.push([creator, count]);
    });
    creatorPairs.sort((a: [string, number], b: [string, number]) => b[1] - a[1]);
    
    preferences.topCreators = [];
    for (let i = 0; i < Math.min(3, creatorPairs.length); i++) {
      preferences.topCreators.push(creatorPairs[i][0]);
    }

    // åˆ†æåŸæ–™åå¥½
    let totalWeight = 0;
    interactions.forEach(interaction => {
      const weight = interaction.interactionType === 'favorite' ? 2 : 1;
      totalWeight += weight;
      
      if (interaction.ingredients) {
        const ingredients = interaction.ingredients.split(',');
        ingredients.forEach(rawIng => {
          const ingredient = this.normalizeIngredient(rawIng.trim());
          const currentWeight = preferences.ingredientWeights.get(ingredient) || 0;
          preferences.ingredientWeights.set(ingredient, currentWeight + weight);
        });
      }
    });

    preferences.avgRecipeWeight = interactions.length > 0 ? totalWeight / interactions.length : 1;

    return preferences;
  }

  /**
   * è§„èŒƒåŒ–åŸæ–™åç§°
   */
  private normalizeIngredient(ingredient: string): string {
    const ingredientNormalizationMap: Record<string, string> = {
      "é‡‘é…’ (gin)": "é‡‘é…’",
      "gin": "é‡‘é…’",
      "ä¼ç‰¹åŠ  (vodka)": "ä¼ç‰¹åŠ ",
      "vodka": "ä¼ç‰¹åŠ ",
      "æœ—å§†é…’ (rum)": "æœ—å§†é…’",
      "rum": "æœ—å§†é…’",
      "é¾™èˆŒå…° (tequila)": "é¾™èˆŒå…°",
      "tequila": "é¾™èˆŒå…°",
      "å¨å£«å¿Œ (whiskey)": "å¨å£«å¿Œ",
      "whiskey": "å¨å£«å¿Œ",
      "whisky": "å¨å£«å¿Œ",
      "ç™½å…°åœ° (brandy)": "ç™½å…°åœ°",
      "brandy": "ç™½å…°åœ°",
      "åˆ©å£é…’ (liqueur)": "åˆ©å£é…’",
      "liqueur": "åˆ©å£é…’",
      "è‹¦ç²¾ (bitters)": "è‹¦ç²¾",
      "bitters": "è‹¦ç²¾",
      "è‹æ‰“æ°´ (soda)": "è‹æ‰“æ°´",
      "soda": "è‹æ‰“æ°´",
      "æ±¤åŠ›æ°´ (tonic)": "æ±¤åŠ›æ°´",
      "tonic": "æ±¤åŠ›æ°´",
      "æŸ æª¬æ± (lemon juice)": "æŸ æª¬æ±",
      "lemon juice": "æŸ æª¬æ±",
      "é’æŸ æ± (lime juice)": "é’æŸ æ±",
      "lime juice": "é’æŸ æ±"
    };

    const lowerIngredient = ingredient.toLowerCase().trim();
    const keys = Object.keys(ingredientNormalizationMap);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = ingredientNormalizationMap[key];
      if (lowerIngredient === key.toLowerCase()) {
        return value;
      }
    }
    return ingredient.replace(/\(.*?\)/g, '').trim();
  }

  /**
   * è·å–æ‰€æœ‰é…æ–¹æ•°æ®
   */
  private async getAllRecipes(): Promise<object> {
    try {
      // è·å–è¶³å¤Ÿå¤šçš„é…æ–¹ç”¨äºæ¨èè®¡ç®—ï¼Œè®¾ç½®è¾ƒå¤§çš„limit
      const response: object = await this.fetchRecipes(1, 1000, '', 'default');
      return response;
    } catch (error) {
      console.error('[APIService] è·å–æ‰€æœ‰é…æ–¹å¤±è´¥:', error);
      throw new APIError('è·å–é…æ–¹æ•°æ®å¤±è´¥', 'FETCH_FAILED');
    }
  }

  /**
   * è®¡ç®—æ¨èå¾—åˆ†
   */
  private calculateRecommendationScores(recipes: RecipeData[], preferences: UserPreferences): ScoredRecipe[] {
    const results: ScoredRecipe[] = [];
    
    recipes.forEach((recipe: RecipeData) => {
      const scores: RecommendationScores = {
        ingredientMatch: 0,
        creatorMatch: 0,
        abvMatch: 0,
        popularity: 0
      };
      const matchReasons: string[] = [];

      // åŸæ–™åŒ¹é…å¾—åˆ† (æƒé‡ 4)
      if (recipe.ingredients) {
        const ingredientList: string[] = recipe.ingredients.split(',');
        const recipeIngredients: string[] = [];
        ingredientList.forEach((ing: string) => {
          recipeIngredients.push(this.normalizeIngredient(ing.trim()));
        });
        
        let rawIngredientScore = 0;
        recipeIngredients.forEach((ing: string) => {
          const weight = preferences.ingredientWeights.get(ing) || 0;
          rawIngredientScore += weight;
        });

        const smoothFactor = 0.5;
        scores.ingredientMatch = 4 * (rawIngredientScore / (preferences.avgRecipeWeight + smoothFactor));
        scores.ingredientMatch = Math.min(scores.ingredientMatch, 4);

        const commonIngredients: string[] = [];
        recipeIngredients.forEach((ing: string) => {
          if (preferences.ingredientWeights.has(ing)) {
            commonIngredients.push(ing);
          }
        });
        
        if (commonIngredients.length > 0) {
          const displayIngredients: string[] = [];
          for (let i = 0; i < Math.min(3, commonIngredients.length); i++) {
            displayIngredients.push(commonIngredients[i]);
          }
          const display = displayIngredients.join('ã€');
          matchReasons.push(`å¯èƒ½å–œæ¬¢çš„åŸæ–™: ${display}${commonIngredients.length > 3 ? 'ç­‰' : ''}`);
        }
      }

      // åˆ›å»ºè€…åŒ¹é…å¾—åˆ† (æƒé‡ 3)
      if (recipe.createdBy && preferences.topCreators.includes(recipe.createdBy)) {
        scores.creatorMatch = 3;
        matchReasons.push(`å¯èƒ½å–œæ¬¢çš„è°ƒé…’å¸ˆ: ${recipe.createdBy}`);
      }

      // é…’ç²¾åº¦åŒ¹é…å¾—åˆ† (æƒé‡ 2)
      if (preferences.preferredAbv > 0 && recipe.estimatedAbv > 0) {
        const diff = Math.abs(recipe.estimatedAbv - preferences.preferredAbv);
        scores.abvMatch = Math.max(0, 2 * (1 - diff / 20));
        if (scores.abvMatch > 1.0) {
          matchReasons.push(`å¯èƒ½å–œæ¬¢çš„é…’ç²¾æµ“åº¦: ${recipe.estimatedAbv}%`);
        }
      }

      // äººæ°”å¾—åˆ† (æƒé‡ 1.5)
      const totalInteractions = (recipe.likeCount || 0) + (recipe.favoriteCount || 0);
      if (totalInteractions > 0) {
        scores.popularity = Math.min(1.5, 1.5 * Math.log(1 + totalInteractions / 50));
        if (totalInteractions > 10) {
          matchReasons.push(`çƒ­é—¨é…æ–¹ (å·²æœ‰${totalInteractions}æ¬¡ğŸ‘&â­)`);
        }
      }

      const totalScore = scores.ingredientMatch + scores.creatorMatch + scores.abvMatch + scores.popularity;

      const scoredRecipe: ScoredRecipe = {
        id: recipe.id,
        name: recipe.name,
        estimatedAbv: recipe.estimatedAbv,
        createdBy: recipe.createdBy,
        ingredients: recipe.ingredients,
        likeCount: recipe.likeCount,
        favoriteCount: recipe.favoriteCount,
        scores: scores,
        totalScore: totalScore,
        matchReasons: matchReasons
      };
      
      results.push(scoredRecipe);
    });
    
    return results;
  }

  /**
   * æ ¼å¼åŒ–æ¨èç»“æœ
   */
  private formatRecommendation(recipe: ScoredRecipe): RecommendationResult {
    const maxPossibleScore = 4 + 3 + 2 + 1.5; // æ€»æƒé‡
    const matchPercentage = Math.min(100, Math.round((recipe.totalScore / maxPossibleScore) * 100));

    let reasons: string[] = [];
    for (let i = 0; i < Math.min(3, recipe.matchReasons.length); i++) {
      reasons.push(recipe.matchReasons[i]);
    }
    if (reasons.length === 0) {
      reasons = ['æ‚¨å¯èƒ½å–œæ¬¢çš„æ–°é…æ–¹'];
    }
    const reasonText = reasons.join(' â€¢ ');

    const result: RecommendationResult = {
      id: recipe.id,
      name: recipe.name,
      estimatedAbv: recipe.estimatedAbv,
      matchPercentage: matchPercentage,
      reason: reasonText,
      reasons: reasons,
      likeCount: recipe.likeCount || 0
    };

    return result;
  }
  
  /**
   * åˆ‡æ¢ç‚¹èµçŠ¶æ€
   * @param recipeId é…æ–¹ID
   */
  public async toggleLike(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/like`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('ç‚¹èµæ“ä½œå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] ç‚¹èµæ“ä½œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ç‚¹èµè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * åˆ‡æ¢æ”¶è—çŠ¶æ€
   * @param recipeId é…æ–¹ID
   */
  public async toggleFavorite(recipeId: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/favorite`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.POST);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('æ”¶è—æ“ä½œå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ”¶è—æ“ä½œå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ”¶è—è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–è¯„è®ºåˆ—è¡¨
   * @param recipeId é…æ–¹ID
   */
  public async fetchComments(recipeId: string): Promise<Array<object>> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/comments`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as Array<object>;
      } else {
        throw new APIError('è·å–è¯„è®ºå¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–è¯„è®ºå¤±è´¥:', error);
      return [];
    }
  }
  
  /**
   * æ·»åŠ è¯„è®º
   * @param recipeId é…æ–¹ID
   * @param text è¯„è®ºå†…å®¹
   * å¯¹åº” server.js: POST /api/recipes/:id/comments
   */
  public async addComment(recipeId: string, text: string): Promise<object> {
    try {
      const url = `${this.baseURL}/api/recipes/${recipeId}/comments`;
      const requestBody: CommentRequestBody = {
        commentText: text
      };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      // server.js è¿”å› 201 Created
      if (response.responseCode === 201 || response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError('æ·»åŠ è¯„è®ºå¤±è´¥', 'OPERATION_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ·»åŠ è¯„è®ºå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ·»åŠ è¯„è®ºè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·æ”¶è—åˆ—è¡¨
   */
  public async fetchUserFavorites(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/favorites`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„ (æœåŠ¡å™¨ç›´æ¥è¿”å›æ•°ç»„çš„æƒ…å†µ)
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserFavorites: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼ { data: [...] }
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserFavorites: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserFavorites: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–æ”¶è—å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–æ”¶è—å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–æ”¶è—è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·åˆ›å»ºçš„é…æ–¹åˆ—è¡¨
   */
  public async fetchUserCreatedRecipes(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/created-recipes`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„ (æœåŠ¡å™¨ç›´æ¥è¿”å›æ•°ç»„çš„æƒ…å†µ)
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserCreatedRecipes: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼ { data: [...] }
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserCreatedRecipes: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserCreatedRecipes: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–é…æ–¹å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–é…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–é…æ–¹è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·ç‚¹èµåˆ—è¡¨
   */
  public async fetchUserLikes(): Promise<Array<object>> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/likes`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        
        // ç­–ç•¥1: ç›´æ¥è¿”å›æ•°ç»„
        if (Array.isArray(result)) {
          console.info('[APIService] fetchUserLikes: ç›´æ¥æ•°ç»„æ ¼å¼, count=' + result.length);
          return result;
        }
        
        // ç­–ç•¥2: APIResponse åŒ…è£…æ ¼å¼
        const wrapped = result as APIResponse<Array<object>>;
        if (wrapped && Array.isArray(wrapped.data)) {
          console.info('[APIService] fetchUserLikes: APIResponseåŒ…è£…æ ¼å¼, count=' + wrapped.data.length);
          return wrapped.data;
        }
        
        console.warn('[APIService] fetchUserLikes: æœªçŸ¥å“åº”æ ¼å¼', result);
        return [];
      } else {
        throw new APIError('è·å–ç‚¹èµå¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–ç‚¹èµå¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–ç‚¹èµè¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * æ›´æ–°ç”¨æˆ·èµ„æ–™
   * @param nickname æ˜µç§°ï¼ˆå¯é€‰ï¼‰
   * @param bio ä¸ªäººç®€ä»‹ï¼ˆå¯é€‰ï¼‰
   */
  public async updateUserProfile(nickname?: string, bio?: string): Promise<void> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/profile`;
      const requestBody: Record<string, string> = {};
      
      if (nickname !== undefined && nickname.length > 0) {
        requestBody['nickname'] = nickname;
      }
      if (bio !== undefined) {
        requestBody['bio'] = bio;
      }
      
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.PUT,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        console.info('[APIService] æ›´æ–°ç”¨æˆ·èµ„æ–™æˆåŠŸ');
        // é€šçŸ¥ç›‘å¬å™¨åˆ·æ–°ç”¨æˆ·ä¿¡æ¯
        this.notifyListeners();
      } else {
        const result:ESObject = response.result as ESObject;
        const message = (result && result['message']) ? result['message'] as string : 'æ›´æ–°å¤±è´¥';
        throw new APIError(message, 'UPDATE_FAILED');
      }
    } catch (error) {
      console.error('[APIService] æ›´æ–°ç”¨æˆ·èµ„æ–™å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('æ›´æ–°ç”¨æˆ·èµ„æ–™è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–ç”¨æˆ·èµ„æ–™è¯¦æƒ…
   */
  public async fetchUserProfile(): Promise<object> {
    try {
      if (!this._isLoggedIn) {
        throw new APIError('è¯·å…ˆç™»å½•', 'NOT_LOGGED_IN');
      }
      
      const url = `${this.baseURL}/api/user/profile`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await http.createHttp().request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result;
        console.info('[APIService] è·å–ç”¨æˆ·èµ„æ–™æˆåŠŸ');
        return result as object;
      } else {
        throw new APIError('è·å–ç”¨æˆ·èµ„æ–™å¤±è´¥', 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–ç”¨æˆ·èµ„æ–™å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–ç”¨æˆ·èµ„æ–™è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * è·å–éšæœºé…æ–¹åˆ—è¡¨(ç”¨äºæ¨è)
   * @param limit æ•°é‡é™åˆ¶
   */
  public async fetchRandomRecipes(limit: number = 100): Promise<Array<object>> {
    try {
      console.info(`[APIService] è·å–éšæœºé…æ–¹, limit=${limit}`);
      // ä½¿ç”¨sort=randomè·å–éšæœºæ’åºçš„é…æ–¹
      const response = await this.fetchRecipes(1, limit, '', 'random');
      
      // ç±»å‹å®‰å…¨çš„è®¿é—®recipeså±æ€§
      const responseObj = response as RecipesResponse;
      if (responseObj && responseObj.recipes) {
        const recipes: Array<object> = responseObj.recipes;
        console.info(`[APIService] è·å–åˆ° ${recipes.length} ä¸ªéšæœºé…æ–¹`);
        return recipes;
      }
      
      console.warn('[APIService] fetchRandomRecipes: å“åº”æ ¼å¼å¼‚å¸¸');
      return [];
    } catch (error) {
      console.error('[APIService] è·å–éšæœºé…æ–¹å¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new APIError('è·å–éšæœºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  // TODO: æ·»åŠ æ›´å¤šAPIæ–¹æ³•
  // - åˆ›å»ºé…æ–¹
  // - åˆ é™¤é…æ–¹
  // - AIç”Ÿæˆé…æ–¹
  // - ç®¡ç†å‘˜ç›¸å…³æ¥å£
  
  /**
   * è·å–è‡ªå®šä¹‰é…æ–¹çš„åŸæ–™åˆ—è¡¨
   */
  public async fetchCustomIngredients(): Promise<object> {
    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}/api/custom/ingredients`;
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      } else {
        throw new APIError(`è·å–åŸæ–™åˆ—è¡¨å¤±è´¥ (${response.responseCode})`, 'FETCH_FAILED');
      }
    } catch (error) {
      console.error('[APIService] è·å–åŸæ–™åˆ—è¡¨å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–åŸæ–™åˆ—è¡¨å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
  
  /**
   * åˆ›å»ºæ–°é…æ–¹
   */
  public async createRecipe(recipeData: object): Promise<object> {
    if (!this.isLoggedIn) {
      throw new APIError('è¯·å…ˆç™»å½•', 'AUTH_REQUIRED');
    }
    
    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}/api/recipes`;
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        recipeData
      );
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 201 || response.responseCode === 200) {
        console.info('[APIService] åˆ›å»ºé…æ–¹æˆåŠŸ');
        return response.result as object;
      } else {
        throw new APIError(`åˆ›å»ºé…æ–¹å¤±è´¥ (${response.responseCode})`, 'CREATE_FAILED');
      }
    } catch (error) {
      console.error('[APIService] åˆ›å»ºé…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('åˆ›å»ºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
  
  /**
   * åˆ›å»ºé…æ–¹ï¼ˆå¸¦å›¾ç‰‡ä¸Šä¼ ï¼‰
   * ä½¿ç”¨ request.uploadFile API ä¸Šä¼ å›¾ç‰‡
   */
  public async createRecipeWithImage(
    recipeData: object,
    imageUri?: string,
    context?: common.UIAbilityContext
  ): Promise<object> {
    if (!this.isLoggedIn) {
      throw new APIError('è¯·å…ˆç™»å½•', 'AUTH_REQUIRED');
    }

    // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œä½¿ç”¨æ™®é€šAPI
    if (!imageUri || imageUri.length === 0) {
      console.info('[APIService] æ— å›¾ç‰‡ï¼Œä½¿ç”¨æ™®é€šAPIåˆ›å»ºé…æ–¹');
      return this.createRecipe(recipeData);
    }

    if (!context) {
      console.error('[APIService] éœ€è¦contextæ¥ä¸Šä¼ å›¾ç‰‡');
      return this.createRecipe(recipeData);
    }

    try {
      const url = `${this.baseURL}/api/custom/cocktails`;
      console.info('[APIService] åˆ›å»ºé…æ–¹(å¸¦å›¾ç‰‡) - URL:', url);
      console.info('[APIService] åŸå§‹å›¾ç‰‡URI:', imageUri);

      // æå–æ•°æ®å­—æ®µ
      const name = Reflect.get(recipeData, 'name') as string;
      const description = Reflect.get(recipeData, 'description') as string;
      const instructions = Reflect.get(recipeData, 'instructions') as string;
      const estimatedAbv = Reflect.get(recipeData, 'estimatedAbv') as number;
      const ingredients = Reflect.get(recipeData, 'ingredients') as Array<object>;

      // å°† instructions è½¬ä¸º steps æ•°ç»„
      const steps = instructions ? instructions.split('\n').filter((s: string) => s.trim().length > 0) : [];

      // å¤åˆ¶å›¾ç‰‡åˆ°åº”ç”¨ç¼“å­˜ç›®å½•
      const cacheDir = context.cacheDir;
      const fileName = `cocktail_${Date.now()}.jpg`;
      const destPath = `${cacheDir}/${fileName}`;
      
      console.info('[APIService] ç¼“å­˜ç›®å½•:', cacheDir);
      console.info('[APIService] ç›®æ ‡è·¯å¾„:', destPath);

      // ä»åª’ä½“åº“URIå¤åˆ¶æ–‡ä»¶åˆ°ç¼“å­˜
      try {
        const srcFile = fs.openSync(imageUri, fs.OpenMode.READ_ONLY);
        const destFile = fs.openSync(destPath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
        
        // è·å–æ–‡ä»¶å¤§å°å¹¶è¯»å–
        const stat = fs.statSync(srcFile.fd);
        const buffer = new ArrayBuffer(stat.size);
        fs.readSync(srcFile.fd, buffer);
        fs.writeSync(destFile.fd, buffer);
        
        fs.closeSync(srcFile);
        fs.closeSync(destFile);
        console.info('[APIService] å›¾ç‰‡å¤åˆ¶æˆåŠŸ, å¤§å°:', stat.size);
      } catch (copyError) {
        console.error('[APIService] å¤åˆ¶å›¾ç‰‡å¤±è´¥:', copyError);
        // å›é€€åˆ°æ™®é€šAPI
        return this.createRecipe(recipeData);
      }

      // ä½¿ç”¨ request.uploadFile ä¸Šä¼ 
      const uploadConfig: request.UploadConfig = {
        url: url,
        header: {
          'Cookie': this.authCookie
        },
        method: 'POST',
        files: [
          {
            filename: fileName,
            name: 'image',
            uri: `internal://cache/${fileName}`,
            type: 'image/jpeg'
          }
        ],
        data: [
          { name: 'name', value: name || '' },
          { name: 'description', value: description || '' },
          { name: 'estimatedAbv', value: String(estimatedAbv || 0) },
          { name: 'ingredients', value: JSON.stringify(ingredients || []) },
          { name: 'steps', value: JSON.stringify(steps) }
        ]
      };

      console.info('[APIService] å¼€å§‹ä¸Šä¼ æ–‡ä»¶...');
      
      const resultObj: APIResponse<string> = { success: true, message: 'é¸¡å°¾é…’åˆ›å»ºæˆåŠŸ' };
      
      return new Promise((resolve, reject) => {
        request.uploadFile(context, uploadConfig)
          .then((uploadTask: request.UploadTask) => {
            console.info('[APIService] ä¸Šä¼ ä»»åŠ¡åˆ›å»ºæˆåŠŸ');
            
            uploadTask.on('complete', (taskStates: Array<request.TaskState>) => {
              console.info('[APIService] ä¸Šä¼ å®Œæˆ:', JSON.stringify(taskStates));
              // æ¸…ç†ç¼“å­˜æ–‡ä»¶
              try {
                fs.unlinkSync(destPath);
              } catch (e) {
                console.warn('[APIService] æ¸…ç†ç¼“å­˜æ–‡ä»¶å¤±è´¥:', e);
              }
              resolve(resultObj);
            });
            
            uploadTask.on('fail', (taskStates: Array<request.TaskState>) => {
              console.error('[APIService] ä¸Šä¼ å¤±è´¥:', JSON.stringify(taskStates));
              // æ¸…ç†ç¼“å­˜æ–‡ä»¶
              try {
                fs.unlinkSync(destPath);
              } catch (e) {
                console.warn('[APIService] æ¸…ç†ç¼“å­˜æ–‡ä»¶å¤±è´¥:', e);
              }
              reject(new APIError('ä¸Šä¼ å¤±è´¥', 'UPLOAD_FAILED'));
            });

            uploadTask.on('progress', (uploadedSize: number, totalSize: number) => {
              console.info(`[APIService] ä¸Šä¼ è¿›åº¦: ${uploadedSize}/${totalSize}`);
            });
          })
          .catch((err: Error) => {
            console.error('[APIService] åˆ›å»ºä¸Šä¼ ä»»åŠ¡å¤±è´¥:', err);
            // æ¸…ç†ç¼“å­˜æ–‡ä»¶
            try {
              fs.unlinkSync(destPath);
            } catch (e) {
              console.warn('[APIService] æ¸…ç†ç¼“å­˜æ–‡ä»¶å¤±è´¥:', e);
            }
            reject(new APIError('åˆ›å»ºä¸Šä¼ ä»»åŠ¡å¤±è´¥', 'UPLOAD_TASK_ERROR'));
          });
      });
    } catch (error) {
      console.error('[APIService] åˆ›å»ºé…æ–¹(å¸¦å›¾ç‰‡)å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('åˆ›å»ºé…æ–¹å¤±è´¥', 'NETWORK_ERROR');
    }
  }
  
  /**
   * AIæ™ºèƒ½è°ƒé…’å¸ˆ - æ ¹æ®å£å‘³æè¿°ç”Ÿæˆé…æ–¹
   * @param tasteDescription å£å‘³æè¿°
   * @param occasion é€‚ç”¨åœºåˆï¼ˆå¯é€‰ï¼‰
   * @param alcoholStrength é…’ç²¾å¼ºåº¦ï¼ˆå¯é€‰ï¼‰
   */
  public async generateAIRecipe(
    tasteDescription: string,
    occasion?: string,
    alcoholStrength?: string
  ): Promise<AIGeneratedRecipe> {
    const httpRequest = http.createHttp();
    try {
      const url = `${this.baseURL}/api/custom/generate-recipe`;
      
      const requestBody: AIRecipeRequest = {
        tasteDescription: tasteDescription
      };
      if (occasion && occasion.length > 0) {
        requestBody.occasion = occasion;
      }
      if (alcoholStrength && alcoholStrength.length > 0) {
        requestBody.alcoholStrength = alcoholStrength;
      }
      
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      
      // è®¾ç½®è¾ƒé•¿çš„è¶…æ—¶æ—¶é—´ï¼Œå› ä¸ºAIç”Ÿæˆéœ€è¦æ—¶é—´
      requestOptions.connectTimeout = 30000;
      requestOptions.readTimeout = 60000;
      
      console.info('[APIService] æ­£åœ¨è°ƒç”¨AIç”Ÿæˆé…æ–¹...');
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        const result = response.result as object;
        console.info('[APIService] AIé…æ–¹ç”ŸæˆæˆåŠŸ, result:', JSON.stringify(result));
        
        // æœåŠ¡ç«¯è¿”å›æ ¼å¼: { success: true, recipe: {...}, generatedAt: ... }
        const recipeData = Reflect.get(result, 'recipe') as AIGeneratedRecipe;
        if (recipeData) {
          return recipeData;
        }
        
        // å…¼å®¹ç›´æ¥è¿”å›é…æ–¹çš„æƒ…å†µ
        if (Reflect.has(result, 'name') && Reflect.has(result, 'ingredients')) {
          return result as AIGeneratedRecipe;
        }
        
        throw new APIError('AIè¿”å›æ•°æ®æ ¼å¼é”™è¯¯', 'PARSE_ERROR');
      } else {
        const errorResult = response.result as object;
        const message = Reflect.get(errorResult, 'message') as string;
        throw new APIError(message || 'AIç”Ÿæˆé…æ–¹å¤±è´¥', 'AI_GENERATE_FAILED');
      }
    } catch (error) {
      console.error('[APIService] AIç”Ÿæˆé…æ–¹å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('AIç”Ÿæˆé…æ–¹è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * è·å–é…æ–¹è¯„åˆ†ä¿¡æ¯
   */
  async fetchRecipeRatings(recipeId: string): Promise<RecipeRatingResponse> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ratings`;
    
    try {
      const requestOptions = this.createRequestOptions(http.RequestMethod.GET);
      console.info(`[APIService] è·å–AIåˆ†ææ•°æ®, URL: ${url}`);
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        let result: object;
        if (typeof response.result === 'string') {
          result = JSON.parse(response.result) as object;
        } else {
          result = response.result as object;
        }
        
        const aiAnalysis = Reflect.get(result, 'aiAnalysis') as string | undefined;
        console.info(`[APIService] AIåˆ†ææ•°æ®: ${aiAnalysis ? 'å·²æ‰¾åˆ°' : 'æ— æ•°æ®'}`);
        
        return {
          success: true,
          hasRating: Reflect.get(result, 'hasRating') as boolean,
          ratings: Reflect.get(result, 'ratings') as RecipeScores | undefined,
          calculatedScore: Reflect.get(result, 'calculatedScore') as number | undefined,
          aiAnalysis: aiAnalysis,
          ratedAt: Reflect.get(result, 'ratedAt') as string | undefined
        };
      }
      throw new APIError('è·å–è¯„åˆ†å¤±è´¥', 'FETCH_RATINGS_FAILED');
    } catch (error) {
      console.error('[APIService] è·å–è¯„åˆ†å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('è·å–è¯„åˆ†è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * ä¿å­˜é…æ–¹è¯„åˆ†
   */
  async saveRecipeRatings(recipeId: string, scores: RecipeScores, aiAnalysis?: string): Promise<object> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ratings`;
    
    try {
      const requestBody: SaveRatingsRequest = { scores: scores, aiAnalysis: aiAnalysis };
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        requestBody
      );
      const response = await httpRequest.request(url, requestOptions);
      
      if (response.responseCode === 200) {
        return response.result as object;
      }
      const errorResult = response.result as object;
      const message = Reflect.get(errorResult, 'message') as string;
      throw new APIError(message || 'ä¿å­˜è¯„åˆ†å¤±è´¥', 'SAVE_RATINGS_FAILED');
    } catch (error) {
      console.error('[APIService] ä¿å­˜è¯„åˆ†å¤±è´¥:', error);
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError('ä¿å­˜è¯„åˆ†è¯·æ±‚å¤±è´¥', 'NETWORK_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }

  /**
   * AIå£å‘³åˆ†æ
   */
  async analyzeRecipeFlavor(recipeId: string): Promise<AIAnalysisResponse> {
    const httpRequest = http.createHttp();
    const url = `${this.baseURL}/api/recipes/${recipeId}/ai-analyze`;
    
    try {
      const emptyBody: EmptyRequest = {};
      const requestOptions = this.createRequestOptions(
        http.RequestMethod.POST,
        { contentType: 'application/json' },
        emptyBody
      );
      requestOptions.connectTimeout = 30000;
      requestOptions.readTimeout = 60000;
      
      console.info(`[APIService] æ­£åœ¨è¿›è¡ŒAIå£å‘³åˆ†æ, URL: ${url}`);
      const response = await httpRequest.request(url, requestOptions);
      
      console.info(`[APIService] AIåˆ†æå“åº”ç : ${response.responseCode}`);
      
      if (response.responseCode === 200) {
        let result: object;
        if (typeof response.result === 'string') {
          result = JSON.parse(response.result) as object;
        } else {
          result = response.result as object;
        }
        return {
          success: true,
          analysis: Reflect.get(result, 'analysis') as string,
          analyzedAt: Reflect.get(result, 'analyzedAt') as string
        };
      }
      
      // è§£æé”™è¯¯å“åº”
      let errorMessage = 'AIåˆ†æå¤±è´¥';
      try {
        let errorResult: object;
        if (typeof response.result === 'string') {
          errorResult = JSON.parse(response.result) as object;
        } else {
          errorResult = response.result as object;
        }
        const msg = Reflect.get(errorResult, 'message') as string;
        if (msg) {
          errorMessage = msg;
        }
      } catch (parseError) {
        console.error('[APIService] è§£æé”™è¯¯å“åº”å¤±è´¥:', parseError);
      }
      console.error(`[APIService] AIåˆ†æå¤±è´¥: ${errorMessage}`);
      throw new APIError(errorMessage, 'AI_ANALYZE_FAILED');
    } catch (error) {
      console.error('[APIService] AIåˆ†æè¯·æ±‚å¼‚å¸¸:', error);
      if (error instanceof APIError) {
        throw error;
      }
      const errMsg = error instanceof Error ? error.message : 'AIåˆ†ææœåŠ¡æš‚æ—¶ä¸å¯ç”¨';
      throw new APIError(errMsg, 'AI_SERVICE_ERROR');
    } finally {
      httpRequest.destroy();
    }
  }
}

// è¯„åˆ†å“åº”æ¥å£
export interface RecipeRatingResponse {
  success: boolean;
  hasRating: boolean;
  ratings?: RecipeScores;
  calculatedScore?: number;
  aiAnalysis?: string;
  ratedAt?: string;
}

// è¯„åˆ†æ•°æ®æ¥å£
export interface RecipeScores {
  visual: number;      // å¤–è§‚ (0-10)
  aroma: number;       // é¦™æ°” (0-10)
  taste: number;       // é£å‘³ (0-10)
  mouthfeel: number;   // å£æ„Ÿ (0-10)
  finish: number;      // ä½™éŸµ (0-10)
}

// AIåˆ†æå“åº”æ¥å£
export interface AIAnalysisResponse {
  success: boolean;
  analysis: string;
  analyzedAt: string;
}

// ä¿å­˜è¯„åˆ†è¯·æ±‚ä½“æ¥å£
interface SaveRatingsRequest {
  scores: RecipeScores;
  aiAnalysis?: string;
}

// ç©ºè¯·æ±‚ä½“æ¥å£
interface EmptyRequest {
  placeholder?: string;
}

// AIé…æ–¹è¯·æ±‚æ¥å£
interface AIRecipeRequest {
  tasteDescription: string;
  occasion?: string;
  alcoholStrength?: string;
}

// AIç”Ÿæˆçš„é…æ–¹æ¥å£
export interface AIGeneratedRecipe {
  name: string;
  description: string;
  ingredients: AIIngredient[];
  steps: string[];
  glassware?: string;
  garnish?: string;
  taste_profile?: TasteProfile;
  tips?: string;
  isDemo?: boolean;
}

// AIé…æ–¹ä¸­çš„é…æ–™æ¥å£
export interface AIIngredient {
  name: string;
  volume: number;
  abv: number;
  category?: string;
}

// å£å‘³é…ç½®æ¥å£
interface TasteProfile {
  sweetness: string;
  sourness: string;
  bitterness: string;
  strength: string;
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export const apiService = APIService.getInstance();
